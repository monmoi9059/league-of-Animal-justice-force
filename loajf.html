<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <title>League of Animal Justice Avenger Force: Operation Dumpster Fire</title>
    <style>
/* --- CSS --- */
body {
    background-color: #0d0d1a;
    color: #00ff41;
    font-family: 'Courier New', monospace;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden; /* Prevent scrolling */
    height: 100vh;
}
h1 {
    font-size: 24px;
    margin-bottom: 5px;
    text-shadow: 0 0 10px #00ff41;
    display: none; /* Hide title to save space, maybe overlay it on menu */
}
#gameContainer {
    position: relative;
    width: 100%;
    height: 100%;
    /* Keep aspect ratio? Or fill? "Fit device screen" usually means fill. */
    /* Let's make it fill. */
    border: 0;
    box-shadow: none;
    background: #000;
}
canvas {
    display: block;
    width: 100%;
    height: 100%;
}
.controls {
    position: absolute;
    bottom: 10px;
    width: 100%;
    text-align: center;
    color: #fff;
    font-size: 12px;
    opacity: 0.5;
    pointer-events: none;
    z-index: 20;
}
/* ... existing styles for HUD/Overlays ... */
#gameUI {
    display: none;
    position: absolute;
    top: 15px; left: 20px; right: 20px;
    font-family: 'Courier New', monospace;
    font-size: 16px;
    font-weight: bold;
    pointer-events: none;
    justify-content: space-between;
    flex-wrap: wrap;
    z-index: 5;
}
.stat-box {
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(4px);
    padding: 8px 15px;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 20px;
    margin-bottom: 5px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    text-shadow: 1px 1px 0 #000;
    color: #fff;
}
#bossHealthContainer {
    display: none;
    position: absolute;
    bottom: 30px; left: 50%;
    transform: translateX(-50%);
    width: 600px; max-width: 90%; /* Responsive width */
    height: 20px;
    border: 2px solid #fff;
    background: #222;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 0 15px rgba(255, 0, 222, 0.5);
    z-index: 5;
}
#bossHealthBar {
    width: 100%; height: 100%;
    background: linear-gradient(90deg, #ff00de, #ff69b4);
    transition: width 0.2s;
}

.overlay-screen {
    display: none;
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(5px);
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    z-index: 10;
}

#menuOverlay {
    background: rgba(10, 10, 20, 0.95);
    justify-content: center; /* Centered menu */
    padding-bottom: 30px;
    z-index: 15;
    display: none;
}

#rosterOverlay {
    background: rgba(0, 0, 0, 0);
    backdrop-filter: none;
    justify-content: center;
    padding-bottom: 30px;
    z-index: 15;
    display: flex;
}

#levelCompleteOverlay {
    background: rgba(20, 40, 20, 0.95);
    z-index: 20;
    display: none;
}

button {
    background: linear-gradient(45deg, #ff00de, #a020f0);
    border: 2px solid #fff;
    color: white;
    padding: 15px 40px;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    text-transform: uppercase;
    box-shadow: 0 0 15px rgba(255, 0, 222, 0.6);
    border-radius: 5px;
    transition: transform 0.1s, box-shadow 0.1s;
    margin-top: 20px;
    pointer-events: auto;
}
button:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(255, 0, 222, 0.8); }

#errorOverlay {
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(50, 0, 0, 0.9);
    color: #ffcccc;
    font-family: monospace;
    padding: 20px;
    box-sizing: border-box;
    white-space: pre-wrap;
    overflow: auto;
    z-index: 9999;
}
#debugHUD {
    position: absolute;
    top: 5px; right: 5px;
    color: lime;
    font-size: 10px;
    background: rgba(0,0,0,0.5);
    padding: 2px;
    pointer-events: none;
    display: none; /* Hide unless needed */
}

/* --- TOUCH CONTROLS --- */
.touch-toggle {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 100;
    background: rgba(0, 0, 0, 0.5);
    color: white;
    border: 1px solid white;
    border-radius: 5px;
    padding: 10px;
    font-size: 24px;
    cursor: pointer;
    opacity: 0.7;
    margin-top: 0; /* Override generic button */
    box-shadow: none;
}

.touch-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Let clicks pass through empty space */
    z-index: 90;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    padding: 20px;
    box-sizing: border-box;
}

.touch-btn {
    pointer-events: auto; /* Enable clicks on buttons */
    background: rgba(255, 255, 255, 0.15);
    border: 2px solid rgba(255, 255, 255, 0.5);
    color: white;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 20px;
    font-weight: bold;
    user-select: none;
    touch-action: manipulation;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 5px;
    padding: 0; /* Reset */
    backdrop-filter: blur(2px);
    transition: transform 0.1s, background 0.1s;
    box-shadow: none; /* Reset */
    text-shadow: 1px 1px 0 #000;
}

.touch-btn:active, .touch-btn.active {
    background: rgba(255, 255, 255, 0.4);
    transform: scale(0.95);
}

.touch-btn.toggle-btn.active {
    background: rgba(0, 255, 65, 0.5);
    border-color: #00ff41;
}

/* D-PAD */
.dpad-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 20px;
    margin-left: 20px;
}
.dpad-row {
    display: flex;
}
.dpad-spacer {
    width: 60px;
    height: 60px;
    margin: 5px;
}

/* ACTIONS */
.action-area {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-bottom: 20px;
    margin-right: 20px;
}

.action-group-main {
    display: flex;
    justify-content: flex-end;
    margin-bottom: 10px;
}
.action-group-sub {
    display: flex;
    justify-content: flex-end;
    flex-wrap: wrap;
    max-width: 280px; /* Force wrap if needed */
}

.action-btn.large {
    width: 80px;
    height: 80px;
    font-size: 24px;
    background: rgba(255, 0, 222, 0.2);
    border-color: rgba(255, 0, 222, 0.5);
}

/* Landscape adjustments for mobile */
@media (max-height: 500px) {
    .touch-btn {
        width: 50px;
        height: 50px;
        font-size: 16px;
    }
    .touch-btn.large {
        width: 70px;
        height: 70px;
    }
    .dpad-spacer {
        width: 50px;
        height: 50px;
    }
    .action-area {
        margin-right: 50px; /* Give thumb space */
    }
    .dpad-area {
        margin-left: 50px;
    }
}

</style>
</head>
<body>

    <div id="gameContainer">
        <!-- Canvas size will be set by JS -->
        <canvas id="gameCanvas"></canvas>
        <div id="errorOverlay"></div>
        <div id="debugHUD">Initializing...</div>

        <!-- HUD -->
        <div id="gameUI">
            <div class="stat-box">HERO: <span id="charName" style="color:#00ff41">IRON MUTT</span></div>
            <div class="stat-box">HP: <span id="healthDisplay" style="color:#ff00de">‚ù§‚ù§‚ù§</span></div>
            <div class="stat-box">LIVES: <span id="livesDisplay" style="color:yellow">3</span></div>
            <div class="stat-box">RESCUES: <span id="rescueDisplay">0</span></div>
            <div class="stat-box">SCORE: <span id="scoreDisplay">0</span></div>
            <div class="stat-box">LEVEL: <span id="levelDisplay">1</span></div>
        </div>

        <div id="bossHealthContainer">
            <div id="bossHealthBar"></div>
        </div>

        <!-- MAIN MENU -->
        <div id="menuOverlay" class="overlay-screen">
             <!-- Title in Menu -->
             <h1 style="font-size: 32px; color: #00ff41; margin-bottom: 40px; text-align: center; max-width: 80%;">
                LEAGUE OF ANIMAL JUSTICE<br>AVENGER FORCE
            </h1>
            <button onclick="window.startGame()">DEPLOY SQUAD</button>
            <button onclick="window.viewRoster()">VIEW TEAM</button>
        </div>

        <!-- ROSTER MENU -->
        <div id="rosterOverlay" class="overlay-screen">
            <button onclick="window.returnToMenu()" style="position: absolute; bottom: 30px;">BACK</button>
        </div>

        <!-- LEVEL COMPLETE -->
        <div id="levelCompleteOverlay" class="overlay-screen">
            <h2 style="color: gold; font-size: 40px; margin-bottom: 20px;">AREA SECURED</h2>
            <div style="font-size: 20px; color: #fff; line-height: 1.6;">
                <p>KILLS: <span id="lcKills" style="color: red">0</span></p>
                <p>RESCUES: <span id="lcRescues" style="color: #00ff41">0</span></p>
                <p>TIME BONUS: <span id="lcTime" style="color: yellow">0</span></p>
            </div>
            <button onclick="window.nextLevel()">NEXT MISSION</button>
        </div>

        <!-- GAME OVER / WIN -->
        <div id="gameOverOverlay" class="overlay-screen">
            <h2 id="ovTitle" style="font-size: 50px; color: #00ff41; margin-bottom: 10px;">MISSION FAILED</h2>
            <p id="ovMsg" style="margin-bottom: 30px; font-size: 20px;">The HOA has won.</p>
            <button onclick="window.returnToBase()">RETURN TO BASE</button>
        </div>

        <div class="controls">
            ARROWS/WASD: Move | SPACE: Jump | SHIFT: Sprint | Z: Shoot | X: Special | C: 2nd Attack | DOWN+Z: Down Attack | F: Flex
        </div>

        <!-- Touch Controls -->
        <button id="controlsToggle" class="touch-toggle">üéÆ</button>

        <div id="touchControls" class="touch-overlay" style="display: none;">
            <div class="dpad-area">
                <div class="dpad-row">
                    <button id="btnUp" class="touch-btn dpad-btn">‚ñ≤</button>
                </div>
                <div class="dpad-row">
                    <button id="btnLeft" class="touch-btn dpad-btn">‚óÄ</button>
                    <div class="dpad-spacer"></div>
                    <button id="btnRight" class="touch-btn dpad-btn">‚ñ∂</button>
                </div>
                <div class="dpad-row">
                    <button id="btnDown" class="touch-btn dpad-btn">‚ñº</button>
                </div>
            </div>

            <div class="action-area">
                <div class="action-group-main">
                    <button id="btnShoot" class="touch-btn action-btn large">Z</button>
                    <button id="btnJump" class="touch-btn action-btn large">SPACE</button>
                </div>
                <div class="action-group-sub">
                    <button id="btnSpecial" class="touch-btn action-btn">X</button>
                    <button id="btnSecondary" class="touch-btn action-btn">C</button>
                    <button id="btnFlex" class="touch-btn action-btn">F</button>
                    <button id="btnSprint" class="touch-btn action-btn toggle-btn">RUN</button>
                </div>
            </div>
        </div>
    </div>


<script>
// Global Scope Function
function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

function checkRectOverlap(r1, r2) {
    if (!r1 || !r2) return false;
    return rectIntersect(r1.x, r1.y, r1.w, r1.h, r2.x, r2.y, r2.w, r2.h);
}

// For Node.js testing environment
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { rectIntersect, checkRectOverlap };
}

</script>

<script>
window.onerror = function(message, source, lineno, colno, error) {
    console.error("Global Error:", message, "at", lineno, ":", colno);
    const overlay = document.getElementById('errorOverlay');
    if (overlay) {
        overlay.style.display = 'block';
        overlay.innerHTML += `<div><strong>Error:</strong> ${message} <br><small>${source}:${lineno}</small></div><hr>`;
    }
};

</script>

<script>
(function() {
// --- constants.js ---
// --- CONSTANTS ---
window.canvas = document.getElementById('gameCanvas');
window.ctx = canvas.getContext('2d');
window.debugHUD = document.getElementById('debugHUD');
window.TILE_SIZE = 40;
window.GRAVITY = 0.6;
window.FRICTION = 0.85;
window.ACCELERATION = 0.8;
window.JUMP_FORCE = -13;
window.TERMINAL_VELOCITY = 15;
window.LEVEL_WIDTH = 400;
window.LEVEL_HEIGHT = 60;
window.FPS = 60;
window.INTERVAL = 1000 / FPS;

// --- ASSETS ---
window.C = {
    dirtBase: "#5d4037", dirtLight: "#8d6e63", grassTop: "#4caf50",
    stoneBase: "#546e7a", stoneLight: "#78909c",
    skyTop: "#1e3c72", skyBot: "#2a5298",
    checkpoint: "#00ff41", leash: "#555", tank: "#e74c3c", ladder: "#d35400"
};

// --- ROSTER ---
window.CHARACTERS = [
    { id: 'pug', name: 'IRON MUTT', type: 'dog_flat', cSkin: '#f3cf98', cDark: '#3b302a', cSuit: '#b0c4de', pType: 'laser', pColor: '#a020f0' },
    { id: 'raccoon', name: 'CPT TRASH', type: 'raccoon', cSkin: '#888', cDark: '#444', cSuit: '#555', pType: 'boomerang', pColor: '#aaa' },
    { id: 'cat', name: 'BAT CAT', type: 'cat', cSkin: '#222', cDark: '#000', cSuit: '#111', pType: 'boomerang', pColor: '#ff69b4' },
    { id: 'corgi', name: 'THOR-GI', type: 'dog_pointy', cSkin: '#E3C099', cDark: '#FFF', cSuit: '#333', pType: 'boomerang', pColor: '#00FFFF' },
    { id: 'hulk', name: 'HULK-POODLE', type: 'poodle', cSkin: '#00FF00', cDark: '#006400', cSuit: '#800080', pType: 'melee_smash', pColor: '#00FF00' },
    { id: 'spider', name: 'SPIDER-PIG', type: 'pig', cSkin: '#FFC0CB', cDark: '#FF69B4', cSuit: '#FF0000', pType: 'gun', pColor: '#FFF' },
    { id: 'wolvie', name: 'WOLVER-WEENIE', type: 'dog_long', cSkin: '#8B4513', cDark: '#000', cSuit: '#FFFF00', pType: 'melee_slash', pColor: '#C0C0C0' },
    { id: 'dead', name: 'DEAD-POODLE', type: 'poodle', cSkin: '#FF0000', cDark: '#000', cSuit: '#333', pType: 'gun', pColor: '#FF0000' },
    { id: 'cap', name: 'CAPTAIN EAGLE', type: 'bird', cSkin: '#FFF', cDark: '#A52A2A', cSuit: '#0000FF', pType: 'boomerang', pColor: '#FFF' },
    { id: 'ironmouse', name: 'IRON-MOUSE', type: 'rodent', cSkin: '#808080', cDark: '#404040', cSuit: '#FF0000', pType: 'laser', pColor: '#FFFF00' },
    { id: 'widow', name: 'BLACK WIDOW-PUG', type: 'dog_flat', cSkin: '#000', cDark: '#111', cSuit: '#222', pType: 'gun', pColor: '#00FFFF' },
    { id: 'hawkeye', name: 'HAWK-HEDGEHOG', type: 'hedgehog', cSkin: '#D2B48C', cDark: '#8B4513', cSuit: '#800080', pType: 'grenade', pColor: '#DDD' },
    { id: 'strange', name: 'DR STRANGE-CAT', type: 'cat', cSkin: '#444', cDark: '#222', cSuit: '#0000FF', pType: 'magic', pColor: '#FFA500' },
    { id: 'panther', name: 'BLACK PANTHER', type: 'cat', cSkin: '#111', cDark: '#000', cSuit: '#222', pType: 'melee_slash', pColor: '#800080' },
    { id: 'ant', name: 'ANT-EATER-MAN', type: 'anteater', cSkin: '#808080', cDark: '#404040', cSuit: '#FF0000', pType: 'melee_smash', pColor: '#FF0000' },
    { id: 'starlord', name: 'STAR-LORD-FOX', type: 'fox', cSkin: '#FF8C00', cDark: '#8B0000', cSuit: '#8B4513', pType: 'laser', pColor: '#FFFF00' },
    { id: 'gamora', name: 'GAMORA-GECKO', type: 'lizard', cSkin: '#00FF00', cDark: '#006400', cSuit: '#000', pType: 'melee_slash', pColor: '#00FF00' },
    { id: 'drax', name: 'DRAX-BULLDOG', type: 'dog_flat', cSkin: '#008000', cDark: '#FF0000', cSuit: '#000080', pType: 'melee_slash', pColor: '#CCC' },
    { id: 'groot', name: 'GROOT-BARK', type: 'tree', cSkin: '#8B4513', cDark: '#A0522D', cSuit: '#654321', pType: 'melee_smash', pColor: '#8B4513' },
    { id: 'rocket', name: 'ROCKET-RABBIT', type: 'rabbit', cSkin: '#A9A9A9', cDark: '#696969', cSuit: '#FF4500', pType: 'grenade', pColor: '#FF4500' },
    { id: 'vision', name: 'VISION-ZEBRA', type: 'horse', cSkin: '#FFC0CB', cDark: '#008000', cSuit: '#FFFF00', pType: 'laser', pColor: '#FFFF00' },
    { id: 'scarlet', name: 'SCARLET-SKUNK', type: 'skunk', cSkin: '#000', cDark: '#FFF', cSuit: '#FF0000', pType: 'magic', pColor: '#FF0000' },
    { id: 'quick', name: 'QUICK-CHEETAH', type: 'cat', cSkin: '#D3D3D3', cDark: '#A9A9A9', cSuit: '#87CEEB', pType: 'melee_slash', pColor: '#87CEEB' },
    { id: 'winter', name: 'WINTER-WOLF', type: 'dog_pointy', cSkin: '#FFF', cDark: '#808080', cSuit: '#000', pType: 'gun', pColor: '#C0C0C0' },
    { id: 'falcon', name: 'FALCON-PIGEON', type: 'bird', cSkin: '#808080', cDark: '#696969', cSuit: '#FF0000', pType: 'gun', pColor: '#CCC' },
    { id: 'war', name: 'WAR-RHINO', type: 'rhino', cSkin: '#708090', cDark: '#2F4F4F', cSuit: '#000', pType: 'grenade', pColor: '#999' },
    { id: 'dare', name: 'DAREDEVIL-DOG', type: 'dog_pointy', cSkin: '#B22222', cDark: '#800000', cSuit: '#FF0000', pType: 'melee_slash', pColor: '#FF0000' },
    { id: 'punish', name: 'PUNISHER-PENGUIN', type: 'bird', cSkin: '#000', cDark: '#FFF', cSuit: '#000', pType: 'spread', pColor: '#FFF' },
    { id: 'shang', name: 'SHANG-CHI-PANDA', type: 'bear', cSkin: '#000', cDark: '#FFF', cSuit: '#FF0000', pType: 'melee_smash', pColor: '#FFD700' },
    { id: 'eternal', name: 'ETERNAL-ELEPHANT', type: 'elephant', cSkin: '#808080', cDark: '#696969', cSuit: '#FFD700', pType: 'magic', pColor: '#FFD700' },
    { id: 'moon', name: 'MOON-OWL', type: 'bird', cSkin: '#FFF', cDark: '#EEE', cSuit: '#DDD', pType: 'boomerang', pColor: '#FFF' },
    { id: 'shehulk', name: 'SHE-HULK-HAMSTER', type: 'rodent', cSkin: '#32CD32', cDark: '#006400', cSuit: '#800080', pType: 'melee_smash', pColor: '#00FF00' },
    { id: 'ghost', name: 'GHOST-GOAT', type: 'goat', cSkin: '#FFF', cDark: '#FF4500', cSuit: '#000', pType: 'melee_slash', pColor: '#FF4500' },
    { id: 'unicorncyborg', name: 'UNICORN-CYBORG', type: 'robot', cSkin: '#6495ED', cDark: '#FFEBCD', cSuit: '#2E8B57', pType: 'lightning', pColor: '#FFE4C4' },
    { id: 'creaturehedgehog', name: 'CREATURE-HEDGEHOG', type: 'hedgehog', cSkin: '#00FF00', cDark: '#DAA520', cSuit: '#008B8B', pType: 'melee_smash', pColor: '#40E0D0' },
    { id: 'storestump', name: 'STORE-STUMP', type: 'tree', cSkin: '#006400', cDark: '#6495ED', cSuit: '#000000', pType: 'boomerang', pColor: '#FFDEAD' },
    { id: 'galaxygod', name: 'GALAXY-GOD', type: 'human', cSkin: '#F0F8FF', cDark: '#BDB76B', cSuit: '#DAA520', pType: 'shuriken', pColor: '#FAF0E6' },
    { id: 'wraithhouse', name: 'WRAITH-HOUSE', type: 'stone', cSkin: '#800000', cDark: '#98FB98', cSuit: '#000080', pType: 'acid_spit', pColor: '#5F9EA0' },
    { id: 'ninjakangaroo', name: 'NINJA-KANGAROO', type: 'rabbit', cSkin: '#DCDCDC', cDark: '#F0FFF0', cSuit: '#8FBC8F', pType: 'card_throw', pColor: '#808080' },
    { id: 'devilcastle', name: 'DEVIL-CASTLE', type: 'stone', cSkin: '#48D1CC', cDark: '#008000', cSuit: '#0000FF', pType: 'water_gun', pColor: '#7CFC00' },
    { id: 'aquaalpaca', name: 'AQUA-ALPACA', type: 'horse', cSkin: '#FFE4E1', cDark: '#FFDEAD', cSuit: '#F5DEB3', pType: 'rocket', pColor: '#FAFAD2' },
    { id: 'makeupgate', name: 'MAKEUP-GATE', type: 'stone', cSkin: '#FFDEAD', cDark: '#F0F8FF', cSuit: '#D2B48C', pType: 'fireball', pColor: '#008000' },
    { id: 'alienboulder', name: 'ALIEN-BOULDER', type: 'stone', cSkin: '#808080', cDark: '#FAEBD7', cSuit: '#006400', pType: 'ice_beam', pColor: '#00BFFF' },
    { id: 'skeletonram', name: 'SKELETON-RAM', type: 'goat', cSkin: '#006400', cDark: '#800080', cSuit: '#00FA9A', pType: 'gun', pColor: '#B0C4DE' },
    { id: 'aquariumforest', name: 'AQUARIUM-FOREST', type: 'tree', cSkin: '#FFFAFA', cDark: '#1E90FF', cSuit: '#556B2F', pType: 'laser', pColor: '#F5F5DC' },
    { id: 'darklog', name: 'DARK-LOG', type: 'tree', cSkin: '#F0E68C', cDark: '#00FFFF', cSuit: '#00CED1', pType: 'water_gun', pColor: '#FFFFFF' },
    { id: 'factoryskeleton', name: 'FACTORY-SKELETON', type: 'skeleton', cSkin: '#FDF5E6', cDark: '#FFFACD', cSuit: '#556B2F', pType: 'acid_spit', pColor: '#F5F5F5' },
    { id: 'defenderroof', name: 'DEFENDER-ROOF', type: 'stone', cSkin: '#A52A2A', cDark: '#0000FF', cSuit: '#000000', pType: 'boomerang', pColor: '#D2691E' },
    { id: 'robbereagle', name: 'ROBBER-EAGLE', type: 'bird', cSkin: '#F8F8FF', cDark: '#4682B4', cSuit: '#3CB371', pType: 'lightning', pColor: '#20B2AA' },
    { id: 'professorskunk', name: 'PROFESSOR-SKUNK', type: 'skunk', cSkin: '#F4A460', cDark: '#800000', cSuit: '#2F4F4F', pType: 'rocket', pColor: '#800000' },
    { id: 'earthbuffalo', name: 'EARTH-BUFFALO', type: 'cow', cSkin: '#7FFF00', cDark: '#4169E1', cSuit: '#FFFF00', pType: 'fireball', pColor: '#00FFFF' },
    { id: 'ogreguinea', name: 'OGRE-GUINEA', type: 'rodent', cSkin: '#FFE4C4', cDark: '#708090', cSuit: '#2F4F4F', pType: 'gun', pColor: '#00CED1' },
    { id: 'artistalien', name: 'ARTIST-ALIEN', type: 'alien', cSkin: '#FFEBCD', cDark: '#ADFF2F', cSuit: '#0000CD', pType: 'ice_beam', pColor: '#F5F5F5' },
    { id: 'firedonkey', name: 'FIRE-DONKEY', type: 'horse', cSkin: '#191970', cDark: '#800000', cSuit: '#2F4F4F', pType: 'water_gun', pColor: '#EEE8AA' },
    { id: 'fighterhawk', name: 'FIGHTER-HAWK', type: 'bird', cSkin: '#F8F8FF', cDark: '#006400', cSuit: '#F0E68C', pType: 'gun', pColor: '#F0FFFF' },
    { id: 'trollpeacock', name: 'TROLL-PEACOCK', type: 'bird', cSkin: '#8FBC8F', cDark: '#40E0D0', cSuit: '#00FF7F', pType: 'gun', pColor: '#FFF5EE' },
    { id: 'detectivemonkey', name: 'DETECTIVE-MONKEY', type: 'monkey', cSkin: '#000080', cDark: '#F5F5F5', cSuit: '#F0FFFF', pType: 'laser', pColor: '#FAEBD7' },
    { id: 'homelizard', name: 'HOME-LIZARD', type: 'lizard', cSkin: '#808000', cDark: '#CD853F', cSuit: '#BC8F8F', pType: 'melee_slash', pColor: '#FFF8DC' },
    { id: 'headsmanshark', name: 'HEADSMAN-SHARK', type: 'fish', cSkin: '#4682B4', cDark: '#00FF7F', cSuit: '#FFE4C4', pType: 'melee_slash', pColor: '#D3D3D3' },
    { id: 'caferaven', name: 'CAFE-RAVEN', type: 'bird', cSkin: '#008B8B', cDark: '#90EE90', cSuit: '#90EE90', pType: 'rocket', pColor: '#FFA500' },
    { id: 'phoenixdemon', name: 'PHOENIX-DEMON', type: 'goat', cSkin: '#EEE8AA', cDark: '#7FFF00', cSuit: '#6B8E23', pType: 'grenade', pColor: '#FFE4C4' },
    { id: 'alienlion', name: 'ALIEN-LION', type: 'cat', cSkin: '#87CEFA', cDark: '#008B8B', cSuit: '#708090', pType: 'melee_slash', pColor: '#00FF00' },
    { id: 'paintervillain', name: 'PAINTER-VILLAIN', type: 'human', cSkin: '#F0E68C', cDark: '#3CB371', cSuit: '#66CDAA', pType: 'laser', pColor: '#F0F8FF' },
    { id: 'mageslime', name: 'MAGE-SLIME', type: 'alien', cSkin: '#00FA9A', cDark: '#BDB76B', cSuit: '#8FBC8F', pType: 'melee_smash', pColor: '#008080' },
    { id: 'journalistceiling', name: 'JOURNALIST-CEILING', type: 'stone', cSkin: '#FFDAB9', cDark: '#A0522D', cSuit: '#228B22', pType: 'melee_slash', pColor: '#800000' },
    { id: 'bakerhamster', name: 'BAKER-HAMSTER', type: 'rodent', cSkin: '#808000', cDark: '#00FFFF', cSuit: '#2E8B57', pType: 'fireball', pColor: '#87CEEB' },
    { id: 'zombiefish', name: 'ZOMBIE-FISH', type: 'fish', cSkin: '#F0F8FF', cDark: '#D2691E', cSuit: '#008000', pType: 'ice_beam', pColor: '#F0FFFF' },
    { id: 'chefdeer', name: 'CHEF-DEER', type: 'goat', cSkin: '#800000', cDark: '#EEE8AA', cSuit: '#FFE4C4', pType: 'rocket', pColor: '#000080' },
    { id: 'resortstone', name: 'RESORT-STONE', type: 'stone', cSkin: '#808080', cDark: '#FAFAD2', cSuit: '#8FBC8F', pType: 'boomerang', pColor: '#00FF7F' },
    { id: 'hospitalchipmunk', name: 'HOSPITAL-CHIPMUNK', type: 'rodent', cSkin: '#FFEFD5', cDark: '#FFFACD', cSuit: '#008B8B', pType: 'card_throw', pColor: '#5F9EA0' },
    { id: 'mutantkoala', name: 'MUTANT-KOALA', type: 'bear', cSkin: '#4682B4', cDark: '#DCDCDC', cSuit: '#008000', pType: 'laser', pColor: '#696969' },
    { id: 'directordirt', name: 'DIRECTOR-DIRT', type: 'stone', cSkin: '#00FA9A', cDark: '#F5FFFA', cSuit: '#FFFAFA', pType: 'spread', pColor: '#008080' },
    { id: 'spectrebison', name: 'SPECTRE-BISON', type: 'cow', cSkin: '#FFF0F5', cDark: '#FFFFF0', cSuit: '#9ACD32', pType: 'card_throw', pColor: '#FFDEAD' },
    { id: 'convictchicken', name: 'CONVICT-CHICKEN', type: 'duck', cSkin: '#D2691E', cDark: '#FFEBCD', cSuit: '#808080', pType: 'grenade', pColor: '#FFFF00' },
    { id: 'innmud', name: 'INN-MUD', type: 'stone', cSkin: '#FAF0E6', cDark: '#008080', cSuit: '#C0C0C0', pType: 'card_throw', pColor: '#9ACD32' },
    { id: 'killerdonkey', name: 'KILLER-DONKEY', type: 'horse', cSkin: '#7FFF00', cDark: '#F0FFFF', cSuit: '#FFFACD', pType: 'grenade', pColor: '#708090' },
    { id: 'professorkangaroo', name: 'PROFESSOR-KANGAROO', type: 'rabbit', cSkin: '#FFE4C4', cDark: '#C0C0C0', cSuit: '#000000', pType: 'spread', pColor: '#40E0D0' },
    { id: 'paramedicpeacock', name: 'PARAMEDIC-PEACOCK', type: 'bird', cSkin: '#00FF00', cDark: '#FFF0F5', cSuit: '#0000FF', pType: 'laser', pColor: '#FDF5E6' },
    { id: 'restaurantwolf', name: 'RESTAURANT-WOLF', type: 'wolf', cSkin: '#191970', cDark: '#FFE4C4', cSuit: '#B8860B', pType: 'ice_beam', pColor: '#E6E6FA' },
    { id: 'knightsheep', name: 'KNIGHT-SHEEP', type: 'goat', cSkin: '#D2691E', cDark: '#B8860B', cSuit: '#F0FFF0', pType: 'acid_spit', pColor: '#000080' },
    { id: 'ranchwombat', name: 'RANCH-WOMBAT', type: 'rodent', cSkin: '#708090', cDark: '#D3D3D3', cSuit: '#000080', pType: 'melee_slash', pColor: '#FFE4C4' },
    { id: 'murdererforest', name: 'MURDERER-FOREST', type: 'tree', cSkin: '#006400', cDark: '#F8F8FF', cSuit: '#4682B4', pType: 'spread', pColor: '#008B8B' },
    { id: 'nightllama', name: 'NIGHT-LLAMA', type: 'horse', cSkin: '#808000', cDark: '#008000', cSuit: '#FFFF00', pType: 'melee_smash', pColor: '#FFFF00' },
    { id: 'musicianturkey', name: 'MUSICIAN-TURKEY', type: 'duck', cSkin: '#228B22', cDark: '#DEB887', cSuit: '#FFFAF0', pType: 'spread', pColor: '#FF0000' },
    { id: 'oozecrow', name: 'OOZE-CROW', type: 'bird', cSkin: '#ADD8E6', cDark: '#228B22', cSuit: '#778899', pType: 'lightning', pColor: '#9ACD32' },
    { id: 'lordblob', name: 'LORD-BLOB', type: 'alien', cSkin: '#008B8B', cDark: '#F8F8FF', cSuit: '#F0E68C', pType: 'water_gun', pColor: '#800080' },
    { id: 'shadowpanda', name: 'SHADOW-PANDA', type: 'bear', cSkin: '#6495ED', cDark: '#008080', cSuit: '#808080', pType: 'melee_smash', pColor: '#F0F8FF' },
    { id: 'spyboulder', name: 'SPY-BOULDER', type: 'stone', cSkin: '#7FFFD4', cDark: '#ADD8E6', cSuit: '#E6E6FA', pType: 'card_throw', pColor: '#98FB98' },
    { id: 'stylistearth', name: 'STYLIST-EARTH', type: 'stone', cSkin: '#006400', cDark: '#F0E68C', cSuit: '#00CED1', pType: 'card_throw', pColor: '#90EE90' },
    { id: 'sparock', name: 'SPA-ROCK', type: 'stone', cSkin: '#000000', cDark: '#DEB887', cSuit: '#000080', pType: 'lightning', pColor: '#0000FF' },
    { id: 'farmpig', name: 'FARM-PIG', type: 'pig', cSkin: '#696969', cDark: '#696969', cSuit: '#FFF5EE', pType: 'lightning', pColor: '#00FFFF' },
    { id: 'guardbrick', name: 'GUARD-BRICK', type: 'stone', cSkin: '#66CDAA', cDark: '#C0C0C0', cSuit: '#40E0D0', pType: 'shuriken', pColor: '#008B8B' },
    { id: 'sunpegasus', name: 'SUN-PEGASUS', type: 'horse', cSkin: '#BDB76B', cDark: '#FFFAFA', cSuit: '#008000', pType: 'lightning', pColor: '#0000CD' },
    { id: 'shopstone', name: 'SHOP-STONE', type: 'stone', cSkin: '#F0FFFF', cDark: '#A0522D', cSuit: '#FFEFD5', pType: 'fireball', pColor: '#E6E6FA' },
    { id: 'princemonster', name: 'PRINCE-MONSTER', type: 'alien', cSkin: '#000080', cDark: '#808000', cSuit: '#FFDEAD', pType: 'gun', pColor: '#FFDEAD' },
    { id: 'directorreindeer', name: 'DIRECTOR-REINDEER', type: 'goat', cSkin: '#8FBC8F', cDark: '#A52A2A', cSuit: '#00FA9A', pType: 'gun', pColor: '#B0C4DE' },
    { id: 'policecroc', name: 'POLICE-CROC', type: 'croc', cSkin: '#228B22', cDark: '#006400', cSuit: '#A52A2A', pType: 'shuriken', pColor: '#A0522D' },
    { id: 'composerfrog', name: 'COMPOSER-FROG', type: 'frog', cSkin: '#32CD32', cDark: '#006400', cSuit: '#9ACD32', pType: 'boomerang', pColor: '#FFDEAD' },
    { id: 'nunturtle', name: 'NUN-TURTLE', type: 'turtle', cSkin: '#2E8B57', cDark: '#006400', cSuit: '#FFFAFA', pType: 'melee_slash', pColor: '#FFE4E1' },
    { id: 'homepumpkin', name: 'HOME-PUMPKIN', type: 'pumpkin', cSkin: '#FFA500', cDark: '#006400', cSuit: '#D3D3D3', pType: 'ice_beam', pColor: '#ADFF2F' },
];


// --- state.js ---

window.gameState = {
    screen: 'MENU',
    running: false,
    score: 0,
    cameraX: 0, cameraY: 0,
    shake: 0,
    frame: 0,
    checkpointsHit: 0,
    rescues: 0,
    lives: 3,
    unlockedCount: 1,
    globalUnlocked: 1, // Alias for legacy code
    spawnPoint: { x: 100, y: 0 },
    bossActive: false,
    hitStop: 0,
    currentLevel: 1, // Added
    levelData: {
        biome: 'forest',
        difficulty: 1,
        width: 400,
        height: 60
    },
    slowMo: 1.0, // For time dilation
    levelCompleteStats: { kills: 0, rescues: 0, time: 0 }
};

window.tiles = [];
window.entities = [];
window.particles = [];
window.damageNumbers = [];
window.debris = [];
window.player = null;

// Global Cooldowns
window.shootCooldown = 0;
window.specialCooldown = 0;
window.lastTime = 0;


// --- utils.js ---
function secureRandom() {
    try {
        const array = new Uint32Array(1);
        // Fallback for secure random
        let cryptoObj = window.crypto || window.msCrypto;
        if (cryptoObj && cryptoObj.getRandomValues) {
             cryptoObj.getRandomValues(array);
             return array[0] / 4294967296;
        }
        return Math.random();
    } catch (e) {
        return Math.random();
    }
}

function spawnDamageNumber(x, y, amount, color="white") {
    damageNumbers.push({ x: x, y: y, text: amount, life: 60, vy: -2, color: color });
}
function spawnExplosion(x, y, color, scale=1) {
    for(let i=0; i<8*scale; i++) particles.push(new Particle(x, y, color));
}
function spawnDebris(x, y, color) {
    // Spawn more, smaller chunks for better "shattering" effect
    for(let i=0; i<6; i++) {
        let chunk = new RockChunk(x + secureRandom()*20, y + secureRandom()*20, color);
        chunk.size = secureRandom() * 4 + 2; // Smaller chunks (2-6px)
        debris.push(chunk);
    }
}
function destroyRadius(cx, cy, r) {
    for(let y = cy - r; y <= cy + r; y++) {
        for(let x = cx - r; x <= cx + r; x++) {
            if(y>=0 && y<LEVEL_HEIGHT && x>=0 && x<LEVEL_WIDTH) {
                if(tiles[y] && tiles[y][x] && tiles[y][x].type === 1) {
                    spawnDebris(x*TILE_SIZE, y*TILE_SIZE, C.dirtLight);
                    tiles[y][x] = { type: 0 };
                }
            }
        }
    }
}
function shakeCamera(amount) {
    gameState.shake = amount;
    if(amount > 10) gameState.hitStop = 3;
}

function createExplosion(x, y, radius, damage) {
    // Visuals
    spawnExplosion(x, y, "orange", radius);

    // Terrain Destruction
    let c = Math.floor(x / TILE_SIZE);
    let r = Math.floor(y / TILE_SIZE);
    destroyRadius(c, r, radius);

    // Entity Damage (Player)
    if (player) {
        let dist = Math.sqrt(Math.pow(player.x - x, 2) + Math.pow(player.y - y, 2));
        // Radius is in tiles, so convert to pixels. Giving slight grace area.
        if (dist < (radius * TILE_SIZE) + 20) {
            player.takeDamage(damage);
        }
    }

    // Entity Damage (Enemies)
    for(let i=0; i<entities.length; i++) {
        let e = entities[i];
        if (e.hp > 0) {
            let dist = Math.sqrt(Math.pow(e.x - x, 2) + Math.pow(e.y - y, 2));
            if (dist < (radius * TILE_SIZE) + 20) {
                 if(e.takeDamage) e.takeDamage(damage, x);
            }
        }
    }
}

function unlockCharacter() {
    if (gameState.globalUnlocked < CHARACTERS.length) {
        gameState.globalUnlocked++;
        gameState.unlockedCount = gameState.globalUnlocked;
        spawnDamageNumber(player.x, player.y - 40, "NEW HERO!", "gold");
        // Maybe visual effect?
        spawnExplosion(player.x, player.y, "gold", 2);
    } else {
        spawnDamageNumber(player.x, player.y - 40, "MAX ROSTER!", "gold");
    }
}


// --- input.js ---
// --- INPUT ---
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// --- TOUCH CONTROLS ---
(function() {
    const touchMap = {
        'btnUp': 'arrowup',
        'btnDown': 'arrowdown',
        'btnLeft': 'arrowleft',
        'btnRight': 'arrowright',
        'btnJump': ' ',
        'btnShoot': 'z',
        'btnSpecial': 'x',
        'btnSecondary': 'c',
        'btnFlex': 'f'
        // Sprint handled separately
    };

    function setKey(key, state) {
        if (keys[key] !== state) {
            keys[key] = state;
        }
    }

    function handleTouch(id, isDown) {
        const btn = document.getElementById(id);
        if (!btn) return;

        // Sprint Toggle Logic
        if (id === 'btnSprint') {
            if (isDown) { // Only toggle on press
                keys['shift'] = !keys['shift'];
                if (keys['shift']) btn.classList.add('active');
                else btn.classList.remove('active');
            }
            return;
        }

        const key = touchMap[id];
        if (key) {
            setKey(key, isDown);
            if (isDown) btn.classList.add('active');
            else btn.classList.remove('active');
        }
    }

    // Attach listeners
    const allBtnIds = Object.keys(touchMap).concat(['btnSprint']);

    allBtnIds.forEach(id => {
        const btn = document.getElementById(id);
        if (!btn) return;

        const start = (e) => {
            e.preventDefault();
            handleTouch(id, true);
        };
        const end = (e) => {
            e.preventDefault();
            handleTouch(id, false);
        };

        btn.addEventListener('touchstart', start, {passive: false});
        btn.addEventListener('touchend', end, {passive: false});
        // Mouse fallbacks for testing
        btn.addEventListener('mousedown', start);
        btn.addEventListener('mouseup', end);
        btn.addEventListener('mouseleave', end);
    });

    // Toggle Visibility
    const toggleBtn = document.getElementById('controlsToggle');
    const controlsDiv = document.getElementById('touchControls');

    function updateToggleBtn() {
        if (controlsDiv.style.display === 'none') {
            toggleBtn.style.opacity = '0.5';
        } else {
            toggleBtn.style.opacity = '1';
        }
    }

    if (toggleBtn && controlsDiv) {
        toggleBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (controlsDiv.style.display === 'none') {
                controlsDiv.style.display = 'flex';
            } else {
                controlsDiv.style.display = 'none';
            }
            updateToggleBtn();
        });

        // Auto-show on touch devices
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            controlsDiv.style.display = 'flex';
        } else {
            // Hide by default on desktop
            controlsDiv.style.display = 'none';
        }
        updateToggleBtn();
    }
})();


// --- particles.js ---
// --- CLASSES ---
class Particle {
    constructor(x, y, color) { this.x=x; this.y=y; this.color=color; this.life=1.0; this.vx = (secureRandom()-0.5)*8; this.vy = (secureRandom()-0.5)*8; this.size = secureRandom()*6+3; }
    update() { this.x+=this.vx; this.y+=this.vy; this.vy+=0.4; this.life-=0.05; }
    draw(ctx) { ctx.save(); ctx.fillStyle=this.color; ctx.globalAlpha=Math.max(0,this.life); ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); ctx.restore(); }
}
class RockChunk {
    constructor(x, y, color) { this.x=x; this.y=y; this.color=color; this.vx=(secureRandom()-0.5)*8; this.vy=-secureRandom()*5-2; this.life=120; this.angle=secureRandom(); this.rotSpeed=(secureRandom()-0.5)*0.5; this.size=secureRandom()*8+4; }
    update() {
        this.x+=this.vx; this.y+=this.vy; this.vy+=0.5; this.angle+=this.rotSpeed; this.life--;
        let r=Math.floor(this.y/TILE_SIZE); let c=Math.floor(this.x/TILE_SIZE);
        if(r>=0 && r<LEVEL_HEIGHT && c>=0 && c<LEVEL_WIDTH && tiles[r] && tiles[r][c] && tiles[r][c].type!==0) { this.vy=0; this.vx*=0.8; this.rotSpeed*=0.8; this.y=r*TILE_SIZE-2; }
    }
    draw(ctx) { ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.fillStyle=this.color; ctx.fillRect(-this.size/2,-this.size/2,this.size,this.size); ctx.restore(); }
}


// --- projectiles.js ---
class Bullet {
    constructor(x, y, dir, isSpecial, charData, isDown = false, isSecondary = false, isUp = false) {
        this.x = x; this.y = y;
        this.life = 80; this.isSpecial = isSpecial; this.w = 15; this.h = 5;
        this.color = charData.pColor;
        this.type = charData.pType;
        this.isEnemy = charData.isEnemy || false;
        this.returnState = 0;

        // DEFAULT VELOCITIES
        this.vx = dir * 15;
        this.vy = (secureRandom() - 0.5) * 2;

        // DOWNWARD SHOT OVERRIDE
        if (isDown) {
            this.vx = 0;
            this.vy = 15;
            this.w = 8; this.h = 20; // Thin vertical projectile
        }

        // UPWARD SHOT OVERRIDE
        if (isUp) {
            this.vx = 0;
            this.vy = -15;
            this.w = 8; this.h = 20; // Thin vertical projectile
        }

        // SECONDARY THROW OVERRIDE (Melee chars)
        if (isSecondary) {
             this.vx = dir * 12;
             this.vy = -5; // Arcing? No, prompt said throw forward. Gravity applied in update for grenades/rockets anyway.
             this.w = 12; this.h = 12;
             this.color = "#ccc"; // Generic projectile color
        }

        // TYPE SPECIFIC ADJUSTMENTS (Overrides defaults unless specific action like Down/Secondary)
        if (!isDown && !isSecondary && !isUp) {
            if (this.type === 'spread') { this.w = 8; this.h = 8; this.vx = dir * 15 + (secureRandom()-0.5)*5; this.vy = (secureRandom()-0.5)*10; }
            if (this.type === 'rocket' || this.type === 'grenade') { this.w = 12; this.h = 12; this.vy = -5; }
            if (this.type === 'boomerang') { this.w = 20; this.h = 20; this.life = 100; }
            if (this.type === 'bolt') { this.w = 25; this.h = 10; }
            if (this.type === 'laser') { this.w = 40; this.h = 5; this.vx = dir * 25; }
            if (this.type === 'magic') { this.w = 10; this.h = 10; this.baseY = y; this.timer = 0; }

            // NEW WEAPONS
            if (this.type === 'fireball') { this.w = 20; this.h = 20; this.vx = dir * 12; }
            if (this.type === 'ice_beam') { this.w = 30; this.h = 6; this.vx = dir * 20; }
            if (this.type === 'sonic_wave') { this.w = 10; this.h = 40; this.vx = dir * 8; this.life = 120; }
            if (this.type === 'lightning') { this.w = 50; this.h = 4; this.vx = dir * 40; } // Very fast
            if (this.type === 'shuriken') { this.w = 15; this.h = 15; this.vx = dir * 18; this.rotation = 0; }
            if (this.type === 'water_gun') { this.w = 12; this.h = 12; this.vx = dir * 14; this.vy = (secureRandom()-0.5)*5; }
            if (this.type === 'acid_spit') { this.w = 10; this.h = 10; this.vx = dir * 10; this.vy = -8; } // Arc
            if (this.type === 'card_throw') { this.w = 12; this.h = 4; this.vx = dir * 22; }
        }
    }
    update() {
        // MOVEMENT LOGIC
        if (this.type === 'grenade' || this.type === 'rocket' || this.type === 'acid_spit') {
            this.vy += 0.3; // Gravity
            this.x += this.vx; this.y += this.vy;
        }
        else if (this.type === 'boomerang' && this.vx !== 0) { // Only boomerang behavior if moving horizontally (not down-shot)
            if (this.returnState === 0) {
                this.x += this.vx; this.vx *= 0.95;
                if (Math.abs(this.vx) < 1) { this.returnState = 1; }
            } else {
                let dx = player.x - this.x; let dy = player.y - this.y;
                let angle = Math.atan2(dy, dx);
                this.x += Math.cos(angle) * 15; this.y += Math.sin(angle) * 15;
                if (Math.abs(dx) < 20 && Math.abs(dy) < 20) this.life = 0;
            }
        }
        else if (this.type === 'magic' && this.vx !== 0) {
            this.timer++; this.x += this.vx; this.y = this.baseY + Math.sin(this.timer * 0.2) * 20;
        }
        else if (this.type === 'shuriken') {
            this.x += this.vx; this.y += this.vy;
            this.rotation += 0.5;
        }
        else if (this.type === 'sonic_wave') {
             this.x += this.vx; this.w += 0.5; this.h += 1; // Grow
             this.y -= 0.5; // Center growth approx
        }
        else { // Standard Linear (includes Down Shot)
            this.x += this.vx; this.y += this.vy;
        }

        this.life--;

        // COLLISIONS
        let c = Math.floor(this.x / TILE_SIZE); let r = Math.floor(this.y / TILE_SIZE);
        let hitWall = false;

        if (r>=0 && r<LEVEL_HEIGHT && c>=0 && c<LEVEL_WIDTH && tiles[r] && tiles[r][c] && tiles[r][c].type !== 0) {
            let t = tiles[r][c];
            // Sonic wave passes through walls but eventually dies? Or just passes?
            if (this.type === 'sonic_wave') {
                 // Pass through, but maybe small visual effect?
            }
            else if (t.type === 1 || t.type === 2) {
                if(this.type === 'boomerang' && this.vx !== 0) {
                    this.returnState = 1;
                    if (t.type === 1) {
                        spawnExplosion(this.x, this.y, C.dirtLight, 1);
                        tiles[r][c] = { type: 0 };
                    }
                }
                else {
                    spawnExplosion(this.x, this.y, C.dirtLight, 1);
                    this.life = 0;
                    if (t.type === 1) { tiles[r][c] = { type: 0 }; }
                    // Reduced destroy radius from 2 to 1 for smaller destruction
                    if (this.isSpecial || this.type === 'rocket' || this.type === 'grenade' || this.type === 'fireball' || this.vy > 0) destroyRadius(c, r, 1);
                }
            }
        }

        // ENEMY COLLISIONS (Player Bullets Only)
        if (!this.isEnemy) {
            for(let i=0; i<entities.length; i++) {
                let e = entities[i];
                if((e.hp !== undefined && e.hp > 0)) {
                    if(rectIntersect(this.x, this.y, this.w, this.h, e.x, e.y, e.w, e.h)) {
                        if(e.takeDamage) e.takeDamage(this.isSpecial ? 5 : 1);
                        if (this.type !== 'boomerang') this.life = 0;
                        else this.returnState = 1;
                    }
                }
            }
        }

        // PLAYER COLLISION (Enemy Bullets Only)
        if (this.isEnemy && player) {
             if(rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
                  player.takeDamage(this.isSpecial ? 2 : 1);
                  if (this.type !== 'boomerang') this.life = 0;
                  else this.returnState = 1;
             }
        }
    }

    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;

        if (this.type === 'boomerang') {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(Date.now() * 0.2);
            ctx.fillStyle = this.color;
            // Draw V shape
            ctx.beginPath();
            ctx.moveTo(0,0); ctx.lineTo(15, -10); ctx.lineTo(10, 0); ctx.lineTo(15, 10); ctx.fill();
            ctx.restore();
        }
        else if (this.type === 'grenade' || this.type === 'rocket') {
             ctx.fillStyle = "#2ecc71"; // Green grenade
             ctx.beginPath(); ctx.arc(cx+this.w/2, cy+this.h/2, 6, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = "#27ae60";
             ctx.fillRect(cx+this.w/2-2, cy-2, 4, 4); // Pin
        }
        else if (this.type === 'bolt' || this.type === 'laser' || this.type === 'ice_beam' || this.type === 'lightning') {
             ctx.fillStyle = this.color;
             ctx.shadowBlur = 10; ctx.shadowColor = this.color;
             drawRoundedRect(ctx, cx, cy, this.w, this.h, 2);
             ctx.shadowBlur = 0;
        }
        else if (this.type === 'fireball') {
             ctx.fillStyle = "#FF4500";
             ctx.beginPath(); ctx.arc(cx+this.w/2, cy+this.h/2, 10, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = "#FFFF00";
             ctx.beginPath(); ctx.arc(cx+this.w/2, cy+this.h/2, 6, 0, Math.PI*2); ctx.fill();
        }
        else if (this.type === 'shuriken') {
             ctx.save();
             ctx.translate(cx + this.w/2, cy + this.h/2);
             ctx.rotate(this.rotation || 0);
             ctx.fillStyle = "#C0C0C0";
             ctx.beginPath();
             for(let i=0; i<4; i++) {
                 ctx.rotate(Math.PI/2);
                 ctx.moveTo(0,0); ctx.lineTo(8, 0); ctx.lineTo(2, 2); ctx.lineTo(0, 0);
             }
             ctx.fill();
             ctx.restore();
        }
        else if (this.type === 'sonic_wave') {
             ctx.strokeStyle = this.color; ctx.lineWidth = 2;
             ctx.beginPath(); ctx.arc(cx, cy+this.h/2, this.h, -Math.PI/4, Math.PI/4); ctx.stroke();
             ctx.beginPath(); ctx.arc(cx-10, cy+this.h/2, this.h-10, -Math.PI/4, Math.PI/4); ctx.stroke();
        }
        else if (this.type === 'card_throw') {
             ctx.fillStyle = "#fff";
             ctx.fillRect(cx, cy, this.w, this.h);
             ctx.fillStyle = "red";
             ctx.beginPath(); ctx.arc(cx+this.w/2, cy+this.h/2, 2, 0, Math.PI*2); ctx.fill();
        }
        else {
            // Standard
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(cx+this.w/2, cy+this.h/2, 5, 0, Math.PI*2); ctx.fill();
        }
    }
}

class MeleeHitbox {
    constructor(x, y, w, h, owner, power=1) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.life = 15; this.power = power;
        this.hp = 1;
        spawnExplosion(x + w/2, y + h/2, "#fff", 0.5);
    }
    update() {
        this.life--;
        if (this.life <= 0) this.hp = 0;
        let c = Math.floor((this.x + this.w/2) / TILE_SIZE);
        let r = Math.floor((this.y + this.h/2) / TILE_SIZE);
        destroyRadius(c, r, 1);
        for(let i=0; i<entities.length; i++) {
            let e = entities[i];
            if(e !== this && ((e.hp !== undefined && e.hp > 0))) {
                if(rectIntersect(this.x, this.y, this.w, this.h, e.x, e.y, e.w, e.h)) {
                    if(e.takeDamage) e.takeDamage(this.power * 2);
                }
            }
        }
    }
    draw(ctx, camX, camY) {
        // Invisible Hitbox
        // ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        // ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
    }
    takeDamage() {}
}

class Package {
    constructor(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.w = 20; this.h = 20; this.life = 120; this.hp = 1; }
    update() {
        this.x += this.vx; this.y += this.vy; this.vy += 0.3; this.life--;
        let c = Math.floor(this.x / TILE_SIZE); let r = Math.floor(this.y / TILE_SIZE);
        let hit = false;
        if (r>=0 && r<LEVEL_HEIGHT && c>=0 && c<LEVEL_WIDTH && tiles[r] && tiles[r][c] && tiles[r][c].type !== 0) hit = true;
        if (rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) hit = true;
        if (hit || this.life <= 0) {
            spawnExplosion(this.x, this.y, "#e67e22", 1);
            if (Math.hypot(player.x - this.x, player.y - this.y) < 60) player.takeDamage();
            destroyRadius(c, r, 1);
            this.life = 0; this.hp = 0;
        }
    }
    takeDamage() { this.life = 0; }
    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;

        ctx.fillStyle = "#d35400"; // Box color
        drawRoundedRect(ctx, cx, cy, this.w, this.h, 2);

        // Tape
        ctx.fillStyle = "#f1c40f";
        ctx.fillRect(cx + 8, cy, 4, this.h);
        ctx.fillRect(cx, cy + 8, this.w, 4);
    }
}

class DebrisProjectile {
    constructor(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.life = 120; this.w = 20; this.h = 20; this.hp = 1; }
    update() {
        this.x += this.vx; this.y += this.vy; this.life--;
        if (rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
            player.takeDamage(); this.life = 0;
        }
    }
    takeDamage() { this.life = 0; }
    draw(ctx, camX, camY) {
        ctx.fillStyle = "#7f8c8d";
        ctx.beginPath(); ctx.arc(this.x - camX + 10, this.y - camY + 10, 8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#95a5a6";
        ctx.beginPath(); ctx.arc(this.x - camX + 8, this.y - camY + 8, 3, 0, Math.PI*2); ctx.fill();
    }
}


// --- items.js ---

class PropaneTank {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = TILE_SIZE; this.h = TILE_SIZE;
        this.hp = 10;
        this.vx = 0; this.vy = 0;
        this.type = 'prop';
    }
    update() {
        this.vy += GRAVITY;
        this.y += this.vy;

        // Simple floor collision
        let r = Math.floor((this.y + this.h) / TILE_SIZE);
        let c = Math.floor((this.x + this.w / 2) / TILE_SIZE);
        if (r >= 0 && r < LEVEL_HEIGHT && c >= 0 && c < LEVEL_WIDTH && tiles[r] && tiles[r][c] && tiles[r][c].solid) {
             this.y = r * TILE_SIZE - this.h;
             this.vy = 0;
             this.vx *= 0.8;
        }
        this.x += this.vx;
    }
    takeDamage(amt, sourceX) {
        this.hp -= amt;
        this.vx = (this.x - sourceX) > 0 ? 5 : -5;
        this.vy = -5;
        if(this.hp <= 0) {
            createExplosion(this.x + this.w/2, this.y + this.h/2, 2, 50);
            this.x = -9999;
        }
    }
    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;
        ctx.fillStyle = "#e74c3c"; // Red tank
        drawRoundedRect(ctx, cx + 5, cy + 5, this.w - 10, this.h - 5, 5);
        ctx.fillStyle = "#bdc3c7"; // Valve
        ctx.fillRect(cx + 12, cy, 16, 5);
        ctx.fillStyle = "white";
        ctx.font = "10px Arial";
        ctx.fillText("GAS", cx+10, cy+25);
    }
}

class FallingBlock {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = TILE_SIZE; this.h = TILE_SIZE;
        this.vx = 0; this.vy = 0;
        this.active = false;
        this.hp = 100;
    }
    update() {
        // Trigger fall if player is near/under? Or just physics object?
        // Let's make it a physics object that falls if unsupported
        this.vy += GRAVITY;
        this.y += this.vy;

        let r = Math.floor((this.y + this.h) / TILE_SIZE);
        let c = Math.floor((this.x + this.w / 2) / TILE_SIZE);

        if (r >= 0 && r < LEVEL_HEIGHT && c >= 0 && c < LEVEL_WIDTH && tiles[r] && tiles[r][c] && tiles[r][c].solid) {
             this.y = r * TILE_SIZE - this.h;
             this.vy = 0;
        }

        // Damage player if falls on head?
        if (Math.abs(this.vx) > 0 || Math.abs(this.vy) > 2) {
            if (checkRectOverlap(this, player)) {
                player.takeDamage(10);
            }
        }
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = "#7f8c8d";
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        ctx.strokeStyle = "#2c3e50";
        ctx.strokeRect(this.x - camX, this.y - camY, this.w, this.h);
    }
}

class BridgeBlock {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = TILE_SIZE; this.h = TILE_SIZE;
        this.hp = 20;
    }
    update() {}
    takeDamage(amt) {
        this.hp -= amt;
        if (this.hp <= 0) {
            this.x = -9999;
            spawnExplosion(this.x, this.y, "grey", 1);
        }
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = "#8e44ad"; // Purple bridge?
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        ctx.beginPath();
        ctx.moveTo(this.x - camX, this.y - camY);
        ctx.lineTo(this.x - camX + this.w, this.y - camY + this.h);
        ctx.stroke();
    }
}

class MechSuit {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = 60; this.h = 80;
        this.occupied = false;
        this.hp = 500;
    }
    update() {
        if (!this.occupied) {
            // Apply gravity
            this.y += 5; // Simple gravity
             let r = Math.floor((this.y + this.h) / TILE_SIZE);
             let c = Math.floor((this.x + this.w / 2) / TILE_SIZE);
             if (r >= 0 && r < LEVEL_HEIGHT && c >= 0 && c < LEVEL_WIDTH && tiles[r] && tiles[r][c] && tiles[r][c].solid) {
                 this.y = r * TILE_SIZE - this.h;
             }

            // Interaction
            if (Math.abs(player.x - this.x) < 50 && Math.abs(player.y - this.y) < 50 && keys['e']) {
                this.enter();
            }
        }
    }
    enter() {
        this.occupied = true;
        player.inMech = true;
        player.mech = this;
        // Visual effect
        spawnExplosion(this.x + 30, this.y + 40, "cyan", 2);
    }
    eject() {
        this.occupied = false;
        player.inMech = false;
        player.mech = null;
        this.x = player.x;
        this.y = player.y;
        this.hp = 0; // Destroy after use? Or leave it? Let's destroy it to prevent spam
        spawnExplosion(this.x + 30, this.y + 40, "cyan", 5);
        this.x = -9999;
    }
    draw(ctx, camX, camY) {
        if (this.occupied) return; // Drawn with player
        let cx = this.x - camX;
        let cy = this.y - camY;
        ctx.fillStyle = "#34495e";
        drawRoundedRect(ctx, cx, cy, this.w, this.h, 10);
        ctx.fillStyle = "#f1c40f"; // Glass
        ctx.fillRect(cx + 15, cy + 10, 30, 20);
        // Legs
        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(cx + 10, cy + 60, 15, 20);
        ctx.fillRect(cx + 35, cy + 60, 15, 20);
        // Arms
        ctx.fillRect(cx - 10, cy + 20, 10, 30);
        ctx.fillRect(cx + 60, cy + 20, 10, 30);
    }
}

class Helicopter {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = 120; this.h = 60;
        this.timer = 0;
        this.isIntro = (x < 1000); // Hacky check if it's at start of level
        this.hp = 1000;
    }
    update() {
        this.timer++;
        // Hover
        this.y += Math.sin(this.timer * 0.1) * 2;

        // Extraction
        // Only extract if it's NOT the intro heli
        if (!this.isIntro && checkRectOverlap(this, player)) {
            gameState.levelComplete = true;
            winGame();
        }

        // If intro heli, fly away after a bit
        if (this.isIntro && this.timer > 100) {
            this.y -= 2;
            this.x -= 2;
            if(this.y < -200) this.x = -9999;
        }
    }
    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;
        ctx.fillStyle = "#27ae60"; // Green friendly heli
        drawRoundedRect(ctx, cx, cy, 100, 50, 10);
        // Rotor
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(cx - 20, cy - 10, 140, 5);
        // Tail
        ctx.fillStyle = "#27ae60";
        ctx.fillRect(cx - 40, cy + 10, 40, 10);
        ctx.fillRect(cx - 50, cy, 10, 30);

        // Ladder
        ctx.strokeStyle = "#fff";
        ctx.beginPath();
        ctx.moveTo(cx + 50, cy + 50);
        ctx.lineTo(cx + 50, cy + 100);
        ctx.stroke();
    }
}

class Dumpster {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = 60; this.h = 40;
        this.hp = 100;
    }
    update() {
        // Gravity
        this.y += 5;
        let r = Math.floor((this.y + this.h) / TILE_SIZE);
        let c = Math.floor((this.x + this.w / 2) / TILE_SIZE);
        if (r >= 0 && r < LEVEL_HEIGHT && c >= 0 && c < LEVEL_WIDTH && tiles[r] && tiles[r][c] && tiles[r][c].solid) {
             this.y = r * TILE_SIZE - this.h;
        }
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = "#2c3e50"; // Dark blue
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        ctx.fillStyle = "#95a5a6"; // Lid
        ctx.fillRect(this.x - camX - 2, this.y - camY - 5, this.w + 4, 5);
    }
}

class TrappedBeast {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = 40; this.h = 40;
        this.freed = false;
        this.hp = 100; // Required to persist in entity list
    }
    update() {
        if (!this.freed && checkRectOverlap(this, player)) {
            this.freed = true;
            spawnExplosion(this.x, this.y, "green", 2);
            unlockCharacter();
            gameState.rescues++;

            // Switch Character Logic
            if (player) {
                // Pick random unlocked character
                let unlockedChars = CHARACTERS.slice(0, gameState.globalUnlocked);
                let newCharIndex = Math.floor(secureRandom() * unlockedChars.length);
                let newCharId = unlockedChars[newCharIndex].id;

                // Ensure switch if possible (optional, but good for UX)
                if (unlockedChars.length > 1 && newCharId === player.charData.id) {
                     newCharIndex = (newCharIndex + 1) % unlockedChars.length;
                     newCharId = unlockedChars[newCharIndex].id;
                }

                player.setCharacter(newCharId);
                player.health = 3; // Reset health
                updateUI(); // Reflect health change

                spawnExplosion(player.x, player.y, "white", 2);
                spawnDamageNumber(player.x, player.y - 60, "SWITCH!", "cyan");
            }
        }
    }
    draw(ctx, camX, camY) {
        if (this.freed) return;
        let cx = this.x - camX;
        let cy = this.y - camY;
        // Cage
        ctx.strokeStyle = "#bdc3c7";
        ctx.lineWidth = 2;
        ctx.strokeRect(cx, cy, this.w, this.h);
        for(let i=10; i<this.w; i+=10) {
            ctx.beginPath(); ctx.moveTo(cx+i, cy); ctx.lineTo(cx+i, cy+this.h); ctx.stroke();
        }
        // Beast inside
        ctx.fillStyle = "#e67e22";
        ctx.beginPath(); ctx.arc(cx+20, cy+20, 10, 0, Math.PI*2); ctx.fill();
    }
}

class Mailman {
    constructor(x, y) {
        this.x = x; this.y = y; this.w = 30; this.h = 60;
        this.vx = 2;
        this.hp = 100;
    }
    update() {
        this.x += this.vx;
        // Turn around
        let c = Math.floor((this.x + (this.vx>0?this.w:0)) / TILE_SIZE);
        let r = Math.floor((this.y + this.h/2) / TILE_SIZE);
        if (tiles[r] && tiles[r][c] && tiles[r][c].solid) this.vx *= -1;
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = "#3498db"; // Uniform
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        ctx.fillStyle = "#ecf0f1"; // Bag
        ctx.fillRect(this.x - camX - 5, this.y - camY + 20, 10, 20);
    }
}

// Expose for testing


// --- enemies.js ---

class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 40;
        this.h = 60;
        this.vx = 0;
        this.vy = 0;
        this.hp = 3;
        this.facing = 1;
        this.state = 'patrol'; // patrol, chase
        this.timer = 0;
        this.shootTimer = 0;
        this.color = "#e74c3c"; // Default color asset
        this.blockedTimer = 0;
        this.speed = 2; // Default patrol speed
        this.chaseSpeed = 3;
    }

    update() {
        this.vy += GRAVITY;
        this.y += this.vy;

        // Vertical Collision (Ground)
        let r = Math.floor((this.y + this.h) / TILE_SIZE);
        let c = Math.floor((this.x + this.w / 2) / TILE_SIZE);

        // Check for solid ground (Type 1=Dirt, 2=Stone)
        if (r >= 0 && r < LEVEL_HEIGHT && c >= 0 && c < LEVEL_WIDTH && tiles[r] && tiles[r][c] && (tiles[r][c].type === 1 || tiles[r][c].type === 2)) {
            this.y = r * TILE_SIZE - this.h;
            this.vy = 0;
        }

        // AI Logic
        if (this.blockedTimer > 0) {
            this.blockedTimer--;
            // Force movement away from wall
            this.vx = this.facing * this.speed;
        } else if (player) {
            let dist = Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2));

            if (dist < 400) {
                this.state = 'chase';
            } else {
                this.state = 'patrol';
            }

            if (this.state === 'patrol') {
                if (this.timer <= 0) {
                    this.timer = 60 + Math.random() * 60;
                    this.facing = Math.random() < 0.5 ? -1 : 1;
                    this.vx = this.facing * this.speed;
                }
                this.timer--;
                this.vx = this.facing * this.speed;
            } else if (this.state === 'chase') {
                // Determine direction based on player, unless just blocked
                this.facing = player.x < this.x ? -1 : 1;
                this.vx = this.facing * this.chaseSpeed;

                this.shootTimer++;
                if (this.shootTimer > 60) {
                    this.shoot();
                    this.shootTimer = 0;
                }
            }
        }

        // Horizontal Movement & Wall/Ledge Collision
        let nextX = this.x + this.vx;

        // Check Wall Ahead
        // Check both top and bottom corners of the hitbox to avoid getting stuck on half-blocks
        let wallCheckY_Top = Math.floor(this.y / TILE_SIZE);
        let wallCheckY_Bot = Math.floor((this.y + this.h - 1) / TILE_SIZE);
        let wallCheckX = Math.floor((nextX + (this.vx > 0 ? this.w : 0)) / TILE_SIZE);

        let hitWall = false;
        if (wallCheckX >= 0 && wallCheckX < LEVEL_WIDTH) {
             let t1 = (tiles[wallCheckY_Top] && tiles[wallCheckY_Top][wallCheckX]);
             let t2 = (tiles[wallCheckY_Bot] && tiles[wallCheckY_Bot][wallCheckX]);

             if ((t1 && (t1.type === 1 || t1.type === 2)) || (t2 && (t2.type === 1 || t2.type === 2))) {
                 hitWall = true;
             }
        } else {
            hitWall = true; // Level boundary
        }

        // Check Ledge Ahead (Ground Check at next position)
        // We check the tile directly below the future feet position
        let ledgeCheckX = Math.floor((nextX + (this.vx > 0 ? this.w : 0)) / TILE_SIZE);
        // Or check center? Standard platformer check usually checks the leading edge.
        // If leading edge is over empty space, turn back.
        let ledgeCheckY = Math.floor((this.y + this.h + 2) / TILE_SIZE); // Look slightly down

        let hitLedge = false;
        if (ledgeCheckY < LEVEL_HEIGHT && ledgeCheckX >= 0 && ledgeCheckX < LEVEL_WIDTH) {
            let t = tiles[ledgeCheckY][ledgeCheckX];
            // If air (0) or non-solid, it's a ledge.
            if (!t || t.type === 0 || t.type === 4 || t.type === 6) {
                hitLedge = true;
            }
        } else {
             hitLedge = true; // Off map bottom
        }

        // React to Obstacle
        if (hitWall || hitLedge) {
            this.vx = 0;
            this.facing *= -1; // Turn around
            this.blockedTimer = 60; // Ignore player/patrol logic for 1 second

            // Push back slightly to avoid sticking
            // this.x += this.facing * 2;
        } else {
            this.x += this.vx;
        }
    }

    shoot() {
        if (!player) return;
        let angle = Math.atan2(player.y - this.y, player.x - this.x);
        angle += (Math.random() - 0.5) * 0.2;
        // Pass minimal valid args
        let b = new Bullet(this.x + this.w/2, this.y + 20, 1, false, { pColor: this.color, pType: 'normal', isEnemy: true });
        b.vx = Math.cos(angle) * 8;
        b.vy = Math.sin(angle) * 8;
        entities.push(b);
    }

    takeDamage(amt, sourceX) {
        this.hp -= amt;
        spawnDamageNumber(this.x, this.y, amt * 10);
        this.vx = (this.x - sourceX) > 0 ? 5 : -5;
        this.vy = -3;
        this.blockedTimer = 10; // Stun briefly

        if (this.hp <= 0) {
            spawnExplosion(this.x + this.w/2, this.y + this.h/2, "red", 1);
            this.x = -9999;
        }
    }

    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;

        // RETRO ROBOT GRUNT
        // Color
        let mainColor = "#c0392b"; // Red
        let metalColor = "#7f8c8d"; // Grey

        // Legs (Tracks)
        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(cx + 5, cy + 40, 10, 20); // L
        ctx.fillRect(cx + 25, cy + 40, 10, 20); // R

        // Body (Blocky)
        ctx.fillStyle = mainColor;
        ctx.fillRect(cx, cy + 10, 40, 30);
        ctx.strokeStyle = "#000"; ctx.lineWidth = 2; ctx.strokeRect(cx, cy+10, 40, 30);

        // Rivets
        ctx.fillStyle = "#fff";
        ctx.fillRect(cx+2, cy+12, 2, 2); ctx.fillRect(cx+36, cy+12, 2, 2);
        ctx.fillRect(cx+2, cy+36, 2, 2); ctx.fillRect(cx+36, cy+36, 2, 2);

        // Head
        ctx.fillStyle = metalColor;
        ctx.fillRect(cx + 10, cy - 5, 20, 15);
        ctx.strokeRect(cx + 10, cy - 5, 20, 15);

        // Eye (Cyclops)
        ctx.fillStyle = "#e74c3c"; // Glowing red
        ctx.beginPath(); ctx.arc(cx + 20 + (this.facing*2), cy + 2, 4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.fillRect(cx + 20 + (this.facing*2) - 1, cy + 1, 2, 2); // Shine

        // Arms (Clamps)
        ctx.fillStyle = metalColor;
        // Front arm based on facing
        let armX = this.facing === 1 ? cx + 30 : cx - 10;
        ctx.fillRect(armX, cy + 15, 20, 8); // Arm

        // Gun/Weapon
        ctx.fillStyle = "#222";
        ctx.fillRect(armX + (this.facing===1?20:-5), cy + 12, 5, 14); // Hand/Gun
    }
}

class FlyingEnemy extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.type = 'fly';
        this.hp = 2;
        this.w = 40; this.h = 40;
    }
    update() {
        if (!player) return;
        let dist = Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2));

        let targetVx = 0;
        let targetVy = 0;

        if (dist < 500) {
            // Move towards player
            targetVx = (player.x - this.x) * 0.02; // Reduced speed for smoother flight
            targetVy = (player.y - this.y - 100) * 0.02; // Hover above

            this.shootTimer++;
            if (this.shootTimer > 100) {
                this.shoot();
                this.shootTimer = 0;
            }
        } else {
            // Idle hover
            targetVx *= 0.9;
            targetVy = Math.sin(Date.now() * 0.005) * 1;
        }

        // Soft Collision with walls (Bounce)
        let nextX = this.x + targetVx;
        let nextY = this.y + targetVy;
        let r = Math.floor((nextY + this.h/2) / TILE_SIZE);
        let c = Math.floor((nextX + this.w/2) / TILE_SIZE);

        if (r >= 0 && r < LEVEL_HEIGHT && c >= 0 && c < LEVEL_WIDTH && tiles[r] && tiles[r][c] && (tiles[r][c].type === 1 || tiles[r][c].type === 2)) {
             // Hit wall, bounce back
             targetVx *= -1.5;
             targetVy *= -1.5;
        }

        this.vx += (targetVx - this.vx) * 0.1;
        this.vy += (targetVy - this.vy) * 0.1;

        this.x += this.vx;
        this.y += this.vy;
    }
    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;

        // UFO / DRONE
        // Dome
        ctx.fillStyle = "rgba(142, 68, 173, 0.6)"; // Purple glass
        ctx.beginPath(); ctx.arc(cx + 20, cy + 15, 15, Math.PI, 0); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.stroke();

        // Brain/Pilot inside
        ctx.fillStyle = "#8e44ad";
        ctx.beginPath(); ctx.arc(cx + 20, cy + 12, 6, 0, Math.PI*2); ctx.fill();

        // Ring Body
        ctx.fillStyle = "#bdc3c7"; // Silver
        ctx.beginPath(); ctx.ellipse(cx + 20, cy + 20, 20, 8, 0, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#7f8c8d"; ctx.stroke();

        // Lights
        let time = Date.now();
        for(let i=0; i<3; i++) {
            ctx.fillStyle = (Math.floor(time / 200) % 3 === i) ? "red" : "#550000";
            ctx.beginPath(); ctx.arc(cx + 10 + (i*10), cy + 20, 2, 0, Math.PI*2); ctx.fill();
        }

        // Thruster
        ctx.fillStyle = "#333";
        ctx.fillRect(cx + 15, cy + 25, 10, 5);
        if (Math.random() < 0.5) {
             ctx.fillStyle = "cyan";
             ctx.beginPath(); ctx.moveTo(cx+15, cy+30); ctx.lineTo(cx+20, cy+40); ctx.lineTo(cx+25, cy+30); ctx.fill();
        }
    }
}

class KamikazeEnemy extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.hp = 1;
        this.speed = 4;
        this.chaseSpeed = 5;
        this.color = "#d35400";
    }
    update() {
        // Use standard logic for movement, but override chase behavior slightly
        super.update();

        // Special Explode Logic
        if (player) {
            let dist = Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2));
            if (dist < 50) this.explode();
        }
    }
    explode() {
        let ex = this.x; let ey = this.y;
        this.x = -9999;
        createExplosion(ex + 20, ey + 30, 2, 50);
    }
    takeDamage(amt, sourceX) {
        super.takeDamage(amt, sourceX);
        if (this.hp <= 0) this.explode();
    }
    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;

        // WALKING BOMB BOT
        // Legs
        ctx.fillStyle = "#333";
        ctx.fillRect(cx + 10, cy + 40, 5, 20);
        ctx.fillRect(cx + 25, cy + 40, 5, 20);

        // Body (Bomb Shape)
        ctx.fillStyle = "#2c3e50"; // Dark body
        ctx.beginPath(); ctx.arc(cx + 20, cy + 25, 18, 0, Math.PI*2); ctx.fill();

        // Fuse / Antenna
        ctx.fillStyle = "#7f8c8d";
        ctx.fillRect(cx + 18, cy, 4, 10);
        // Spark
        if (Math.random() < 0.5) {
             ctx.fillStyle = "yellow";
             ctx.beginPath(); ctx.arc(cx + 20, cy, 4, 0, Math.PI*2); ctx.fill();
        }

        // Face (Screen)
        ctx.fillStyle = "#000";
        ctx.fillRect(cx + 10, cy + 20, 20, 10);
        // Digital Face
        ctx.fillStyle = "red";
        ctx.font = "10px monospace";
        let blink = Math.floor(Date.now() / 100) % 2 === 0;
        ctx.fillText(blink ? ":(" : "X(", cx + 12, cy + 28);

        // Chest Light
        ctx.fillStyle = blink ? "red" : "#500";
        ctx.beginPath(); ctx.arc(cx + 20, cy + 35, 3, 0, Math.PI*2); ctx.fill();
    }
}

class HeavyGunner extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.hp = 10;
        this.w = 50; this.h = 70;
        this.color = "#27ae60";
        this.speed = 0; // Stationary usually, or very slow
        this.chaseSpeed = 0; // Doesn't chase
    }
    update() {
        this.vy += GRAVITY;
        this.y += this.vy;

        // Ground Collision
        let r = Math.floor((this.y + this.h) / TILE_SIZE);
        let c = Math.floor((this.x + this.w / 2) / TILE_SIZE);
        if (r >= 0 && r < LEVEL_HEIGHT && c >= 0 && c < LEVEL_WIDTH && tiles[r] && tiles[r][c] && (tiles[r][c].type === 1 || tiles[r][c].type === 2)) {
            this.y = r * TILE_SIZE - this.h;
            this.vy = 0;
        }

        if (player) {
            let dist = Math.abs(player.x - this.x);
            if (dist < 500) {
                this.facing = player.x < this.x ? -1 : 1;
                this.shootTimer++;
                if (this.shootTimer > 10) {
                     this.shoot();
                     this.shootTimer = 0;
                }
            }
        }
    }
    shoot() {
        if (!player) return;
        let angle = Math.atan2(player.y - this.y, player.x - this.x);
        angle += (Math.random() - 0.5) * 0.4;
        let b = new Bullet(this.x + this.w/2, this.y + 30, 1, false, { pColor: this.color, pType: 'normal', isEnemy: true });
        b.vx = Math.cos(angle) * 10;
        b.vy = Math.sin(angle) * 10;
        entities.push(b);
    }
    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;

        // TANK BOT
        // Treads
        ctx.fillStyle = "#2c3e50";
        drawRoundedRect(ctx, cx, cy + 50, 50, 20, 5);
        // Tread wheels
        ctx.fillStyle = "#7f8c8d";
        for(let i=0; i<3; i++) ctx.beginPath(), ctx.arc(cx + 10 + i*15, cy + 60, 6, 0, Math.PI*2), ctx.fill();

        // Torso
        ctx.fillStyle = "#27ae60"; // Green Armor
        ctx.fillRect(cx + 5, cy + 10, 40, 40);

        // Head (Small, armored)
        ctx.fillStyle = "#1e8449";
        ctx.fillRect(cx + 15, cy, 20, 10);
        // Visor
        ctx.fillStyle = "#f1c40f";
        ctx.fillRect(cx + 18, cy + 2, 14, 4);

        // Minigun Arm
        ctx.fillStyle = "#333";
        let gunX = this.facing === 1 ? cx + 40 : cx - 20;
        ctx.fillRect(gunX, cy + 25, 30, 10); // Barrel
        // Rotation
        let spin = Math.sin(Date.now() * 0.5) * 2;
        ctx.fillStyle = "#111";
        ctx.fillRect(gunX + (this.facing===1?30:0), cy + 22 + spin, 5, 16);
    }
}

class SniperEnemy extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.hp = 2;
        this.range = 800;
        this.aimTimer = 0;
        this.color = "#3498db";
        this.speed = 1;
        this.chaseSpeed = 0; // Holds position
    }
    update() {
        this.vy += GRAVITY;
        this.y += this.vy;

        // Collision
        let r = Math.floor((this.y + this.h) / TILE_SIZE);
        let c = Math.floor((this.x + this.w / 2) / TILE_SIZE);
        if (r >= 0 && r < LEVEL_HEIGHT && c >= 0 && c < LEVEL_WIDTH && tiles[r] && tiles[r][c] && (tiles[r][c].type === 1 || tiles[r][c].type === 2)) {
            this.y = r * TILE_SIZE - this.h;
            this.vy = 0;
        }

        if (player) {
            let dist = Math.abs(player.x - this.x);
            if (dist < this.range) {
                 this.facing = player.x < this.x ? -1 : 1;
                 this.aimTimer++;
                 if (this.aimTimer > 180) {
                     this.shoot();
                     this.aimTimer = 0;
                 }
            } else {
                this.aimTimer = 0;
                // Maybe patrol if player far?
                super.update(); // Use default patrol if out of range
            }
        }
    }
    shoot() {
        if (!player) return;
        let angle = Math.atan2(player.y - this.y, player.x - this.x);
        let b = new Bullet(this.x + this.w/2, this.y + 20, 2, false, { pColor: this.color, pType: 'normal', isEnemy: true });
        b.vx = Math.cos(angle) * 20;
        b.vy = Math.sin(angle) * 20;
        entities.push(b);
    }
    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;

        // SNIPER BOT (Tall, Thin)
        // Legs
        ctx.fillStyle = "#34495e";
        ctx.fillRect(cx + 15, cy + 40, 4, 20);
        ctx.fillRect(cx + 25, cy + 40, 4, 20);

        // Body
        ctx.fillStyle = "#3498db"; // Blue
        ctx.fillRect(cx + 15, cy + 15, 14, 25);

        // Head
        ctx.fillStyle = "#2c3e50";
        ctx.beginPath(); ctx.arc(cx + 22, cy + 10, 8, 0, Math.PI*2); ctx.fill();

        // Eye (Scope)
        ctx.fillStyle = "#000";
        let eyeX = cx + 22 + (this.facing * 4);
        ctx.beginPath(); ctx.arc(eyeX, cy + 10, 4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(eyeX, cy + 10, 2, 0, Math.PI*2); ctx.fill();

        // Rifle
        ctx.fillStyle = "#111";
        let gunLen = 40;
        if(this.facing === 1) {
             ctx.fillRect(cx + 20, cy + 20, gunLen, 4);
             ctx.fillRect(cx + 20, cy + 22, 10, 6); // Stock
        } else {
             ctx.fillRect(cx + 24 - gunLen, cy + 20, gunLen, 4);
             ctx.fillRect(cx + 14, cy + 22, 10, 6);
        }

        // Laser Sight
        if (this.aimTimer > 100 && player) {
            ctx.strokeStyle = "rgba(231, 76, 60, 0.5)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx+this.w/2, cy+22);
            ctx.lineTo(player.x - camX + player.w/2, player.y - camY + player.h/2);
            ctx.stroke();
        }
    }
}

class ShieldBearer extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.hp = 8;
        this.shieldUp = true;
        this.color = "#7f8c8d";
        this.speed = 1;
        this.chaseSpeed = 1;
    }
    update() {
        super.update(); // Use standard wall/ledge logic

        if (player) {
            this.shieldUp = (player.x < this.x && this.facing === -1) || (player.x > this.x && this.facing === 1);
        }
    }
    takeDamage(amt, sourceX) {
        let hitFromFront = (sourceX < this.x && this.facing === -1) || (sourceX > this.x && this.facing === 1);
        if (this.shieldUp && hitFromFront) {
            spawnExplosion(this.x + 20, this.y + 20, "blue", 1);
            spawnDamageNumber(this.x, this.y - 20, "BLOCKED!", "blue");
            this.hp -= amt * 0.1;
        } else {
            this.hp -= amt;
            spawnExplosion(this.x + 20, this.y + 20, "red", 2);
            spawnDamageNumber(this.x, this.y, amt * 10);
        }
        if (this.hp <= 0) {
             this.x = -9999;
             spawnExplosion(this.x, this.y, "red", 3);
        }
    }
    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;

        // RIOT BOT
        // Legs
        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(cx + 5, cy + 40, 10, 20);
        ctx.fillRect(cx + 25, cy + 40, 10, 20);

        // Body
        ctx.fillStyle = "#95a5a6";
        ctx.fillRect(cx + 5, cy + 10, 30, 30);

        // Head
        ctx.fillStyle = "#2c3e50";
        drawRoundedRect(ctx, cx + 10, cy - 5, 20, 15, 5);
        // Visor slit
        ctx.fillStyle = "cyan";
        ctx.fillRect(cx + 12, cy, 16, 2);

        // SHIELD (Draw last so it covers)
        ctx.fillStyle = "rgba(52, 152, 219, 0.6)"; // Energy Blue
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;

        let shieldX = this.facing === 1 ? cx + 25 : cx - 15;
        drawRoundedRect(ctx, shieldX, cy, 30, 60, 5);
        ctx.stroke();

        // Shield details
        ctx.fillStyle = "white";
        ctx.font = "10px Arial";
        ctx.fillText("POLICE", shieldX + 2, cy + 30);
    }
}

class CaptainEnemy extends Enemy {
    constructor(x, y) {
        super(x, y);
        this.hp = 15 + (gameState.currentLevel * 2);
        this.w = 50; this.h = 70;
        this.color = "#9b59b6";
    }
    update() {
        this.vy += GRAVITY;
        this.y += this.vy;

        let r = Math.floor((this.y + this.h) / TILE_SIZE);
        let c = Math.floor((this.x + this.w / 2) / TILE_SIZE);
        if (r >= 0 && r < LEVEL_HEIGHT && c >= 0 && c < LEVEL_WIDTH && tiles[r] && tiles[r][c] && (tiles[r][c].type === 1 || tiles[r][c].type === 2)) {
            this.y = r * TILE_SIZE - this.h;
            this.vy = 0;
        }

        if (player) {
            let dist = Math.abs(player.x - this.x);
            if (dist < 600) {
                this.facing = player.x < this.x ? -1 : 1;
                this.shootTimer++;
                if (this.shootTimer > 90) {
                     this.shootBurst();
                     this.shootTimer = 0;
                }
            }
        }
    }
    shootBurst() {
        if (!player) return;
        for(let i=0; i<3; i++) {
            setTimeout(() => {
                if(this.hp <= 0 || !player) return;
                let angle = Math.atan2(player.y - this.y, player.x - this.x);
                let b = new Bullet(this.x + this.w/2, this.y + 20, 1, false, { pColor: this.color, pType: 'normal', isEnemy: true });
                b.vx = Math.cos(angle) * 12;
                b.vy = Math.sin(angle) * 12;
                b.color = "gold";
                entities.push(b);
            }, i * 100);
        }
    }
    takeDamage(amt, sourceX) {
        this.hp -= amt;
        spawnDamageNumber(this.x, this.y, amt * 10, "gold");
        if (this.hp <= 0) {
             let deathX = this.x;
             let deathY = this.y;
             spawnExplosion(deathX + this.w/2, deathY + this.h/2, "gold", 3);
             this.x = -9999;
             entities.push(new Helicopter(deathX, deathY - 50));
        }
    }
    draw(ctx, camX, camY) {
        let cx = this.x - camX;
        let cy = this.y - camY;

        // CAPTAIN ROBOT
        // Gold Plating
        ctx.fillStyle = "#f1c40f"; // Gold
        drawRoundedRect(ctx, cx, cy, this.w, this.h, 10);

        // Trim
        ctx.fillStyle = "#8e44ad"; // Purple Royal
        ctx.fillRect(cx + 20, cy, 10, this.h);

        // Head
        ctx.fillStyle = "#f39c12";
        ctx.beginPath(); ctx.arc(cx + 25, cy - 10, 15, 0, Math.PI*2); ctx.fill();

        // Crown/Antenna
        ctx.fillStyle = "gold";
        ctx.beginPath(); ctx.moveTo(cx+15, cy-20); ctx.lineTo(cx+25, cy-35); ctx.lineTo(cx+35, cy-20); ctx.fill();

        // Eyes
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(cx + 20, cy - 10, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + 30, cy - 10, 3, 0, Math.PI*2); ctx.fill();
    }
}

class Boss {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 120;
        this.h = 120;
        this.hp = 50 + (gameState.currentLevel * 15); // Increased scaling
        this.maxHp = this.hp;
        this.state = 'idle';
        this.timer = 0;
        this.dirY = 1;
    }
    update() {
        if (!gameState.bossActive && Math.abs(player.x - this.x) < 800) {
            gameState.bossActive = true;
            if(document.getElementById('bossHealthContainer')) document.getElementById('bossHealthContainer').style.display = 'block';
        }
        if (!gameState.bossActive) return;

        // Hover
        this.y += this.dirY * 2;
        if (this.y > (LEVEL_HEIGHT * TILE_SIZE) - this.h - 100 || this.y < 50) this.dirY *= -1;

        this.timer++;

        // Attack Pattern Scaling
        let difficulty = gameState.currentLevel;
        let fireRate = 100;
        if (difficulty >= 5) fireRate = 80;
        if (difficulty >= 10) fireRate = 60;
        if (difficulty >= 15) fireRate = 40;

        if (this.timer > fireRate) {
            let angle = Math.atan2(player.y - this.y, player.x - this.x);
            let speed = 8 + (difficulty * 0.2);

            // Attack 1: Standard Shot
            let b = new Bullet(this.x + 60, this.y + 60, 2, false, { pColor: '#c0392b', pType: 'normal', isEnemy: true });
            b.vx = Math.cos(angle) * speed;
            b.vy = Math.sin(angle) * speed;
            entities.push(b);

            // Attack 2: Spread (Level 3+)
            if (difficulty >= 3) {
                 let spread = 0.2;
                 let b1 = new Bullet(this.x + 60, this.y + 60, 2, false, { pColor: '#c0392b', pType: 'normal', isEnemy: true });
                 b1.vx = Math.cos(angle - spread) * speed;
                 b1.vy = Math.sin(angle - spread) * speed;

                 let b2 = new Bullet(this.x + 60, this.y + 60, 2, false, { pColor: '#c0392b', pType: 'normal', isEnemy: true });
                 b2.vx = Math.cos(angle + spread) * speed;
                 b2.vy = Math.sin(angle + spread) * speed;

                 entities.push(b1);
                 entities.push(b2);
            }

            // Attack 3: Shotgun (Level 6+)
            if (difficulty >= 6) {
                 let spread = 0.4;
                 let b3 = new Bullet(this.x + 60, this.y + 60, 2, false, { pColor: '#c0392b', pType: 'normal', isEnemy: true });
                 b3.vx = Math.cos(angle - spread) * speed;
                 b3.vy = Math.sin(angle - spread) * speed;
                 entities.push(b3);

                 let b4 = new Bullet(this.x + 60, this.y + 60, 2, false, { pColor: '#c0392b', pType: 'normal', isEnemy: true });
                 b4.vx = Math.cos(angle + spread) * speed;
                 b4.vy = Math.sin(angle + spread) * speed;
                 entities.push(b4);
            }

            // Attack 4: Explosive (Level 10+)
            if (difficulty >= 10 && this.timer % (fireRate*2) === 0) {
                // Drop a propane tank
                let tank = new PropaneTank(this.x + 60, this.y + 60);
                tank.vx = (player.x - this.x) * 0.05;
                tank.vy = -5;
                entities.push(tank);
            }

            this.timer = 0;
        }
    }
    takeDamage(amt, sourceX) {
        if (!gameState.bossActive) return;
        this.hp -= amt;
        shakeCamera(2);
        let pct = (this.hp / this.maxHp) * 100;
        if(document.getElementById('bossHealthBar')) document.getElementById('bossHealthBar').style.width = pct + "%";
        spawnDamageNumber(this.x + 60, this.y + 60, amt * 10);
        if (this.hp <= 0) {
            shakeCamera(50);
            spawnExplosion(this.x + 60, this.y + 60, "#ff00de", 5);
            gameState.bossActive = false;
            if(document.getElementById('bossHealthContainer')) document.getElementById('bossHealthContainer').style.display = 'none';

            // Spawn Extraction
            entities.push(new Helicopter(this.x, this.y));

            this.x = -9999;
            gameState.slowMo = 0.2;
            setTimeout(() => gameState.slowMo = 1.0, 2000);
        }
    }
    draw(ctx, camX, camY) {
        if (this.hp <= 0) return;
        let cx = this.x - camX;
        let cy = this.y - camY;

        let shake = 0;
        if (this.hp < this.maxHp * 0.5) shake = (Math.random()-0.5)*4;

        ctx.save();
        ctx.translate(cx + this.w/2 + shake, cy + this.h/2 + shake);

        // Main Canister
        ctx.fillStyle = "#c0392b"; // Red vacuum
        drawRoundedRect(ctx, -40, -50, 80, 100, 10);

        // Shine
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.fillRect(-30, -40, 10, 80);

        // Wheels
        ctx.fillStyle = "#222";
        ctx.beginPath(); ctx.arc(-45, 45, 15, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(45, 45, 15, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#555";
        ctx.beginPath(); ctx.arc(-45, 45, 5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(45, 45, 5, 0, Math.PI*2); ctx.fill();

        // Hose (Snake like)
        ctx.strokeStyle = "#333"; ctx.lineWidth = 15; ctx.lineCap = "round"; ctx.lineJoin = "round";
        ctx.beginPath();
        ctx.moveTo(0, -50);
        ctx.bezierCurveTo(0, -100, -80, -50, -60, 0);
        ctx.stroke();

        // Nozzle head
        ctx.fillStyle = "#222";
        ctx.save();
        ctx.translate(-60, 0);
        ctx.rotate(Math.sin(this.timer*0.1)*0.5);
        ctx.fillRect(-15, -10, 30, 40); // Nozzle
        ctx.fillStyle = "#111";
        ctx.fillRect(-20, 30, 40, 10); // Brush part
        ctx.restore();

        // Face
        // Evil Eyes
        ctx.fillStyle = "#000";
        ctx.beginPath(); ctx.moveTo(-20, -20); ctx.lineTo(-5, -10); ctx.lineTo(-20, 0); ctx.fill();
        ctx.beginPath(); ctx.moveTo(20, -20); ctx.lineTo(5, -10); ctx.lineTo(20, 0); ctx.fill();

        // Grill/Mouth
        ctx.fillStyle = "#222";
        for(let i=0; i<3; i++) {
            ctx.fillRect(-15, 20 + i*8, 30, 4);
        }

        // Name Tag
        ctx.fillStyle = "#fff"; ctx.font = "bold 20px Arial"; ctx.fillText("VACUUM KING", -70, -70);

        ctx.restore();
    }
}

class HelicopterBoss {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.w = 150; this.h = 80;
        this.hp = 200 + (gameState.currentLevel * 20);
        this.maxHp = this.hp;
        this.state = 'fly';
        this.timer = 0;
        this.vx = 2; this.vy = 0;
        this.targetX = x;
    }
    update() {
        if (!gameState.bossActive && Math.abs(player.x - this.x) < 800) {
            gameState.bossActive = true;
            if(document.getElementById('bossHealthContainer')) document.getElementById('bossHealthContainer').style.display = 'block';
        }
        if (!gameState.bossActive) return;

        // Hover Movement
        this.timer++;
        this.y += Math.sin(this.timer * 0.05) * 2;

        // Follow Player (Laggy)
        if (this.timer % 60 === 0) {
            this.targetX = player.x;
        }
        this.x += (this.targetX - this.x) * 0.02;

        let difficulty = gameState.currentLevel;

        // Attack 1: Minigun (Rapid Fire)
        if (this.timer % 10 === 0) {
             let angle = Math.atan2(player.y - this.y, player.x - this.x);
             // Spread
             angle += (Math.random() - 0.5) * 0.2;
             let b = new Bullet(this.x + 75, this.y + 60, 1, false, { pColor: '#f1c40f', pType: 'normal', isEnemy: true });
             // Manually set velocities
             b.vx = Math.cos(angle) * 15;
             b.vy = Math.sin(angle) * 15;
             entities.push(b);
        }

        // Attack 2: Bomb Drop (Every 3s)
        let bombRate = 180;
        if (difficulty >= 10) bombRate = 120;

        if (this.timer % bombRate === 0) {
            // Drop bomb
            let bomb = new PropaneTank(this.x + 75, this.y + 80);
            if (difficulty >= 5) {
                bomb.vx = (player.x - this.x) * 0.05; // Toss it
            }
            entities.push(bomb);
        }

        // Attack 3: Strafing Run (Level 15+)
        // (Simplified: just moves faster towards player)
        if (difficulty >= 15) {
             this.x += (player.x - this.x) * 0.01;
        }
    }
    takeDamage(amt, sourceX) {
        if (!gameState.bossActive) return;
        this.hp -= amt;
        let pct = (this.hp / this.maxHp) * 100;
        if(document.getElementById('bossHealthBar')) document.getElementById('bossHealthBar').style.width = pct + "%";
        spawnDamageNumber(this.x + 75, this.y + 40, amt * 10, "cyan");
        shakeCamera(2);

        if (this.hp <= 0) {
            shakeCamera(100);
            spawnExplosion(this.x + 75, this.y + 40, "orange", 10);
            gameState.bossActive = false;
            if(document.getElementById('bossHealthContainer')) document.getElementById('bossHealthContainer').style.display = 'none';
            this.x = -9999;
            entities.push(new Helicopter((LEVEL_WIDTH - 15) * TILE_SIZE, 8 * TILE_SIZE)); // Extraction Heli
            gameState.slowMo = 0.1;
            setTimeout(() => gameState.slowMo = 1.0, 3000);
        }
    }
    draw(ctx, camX, camY) {
        if (this.hp <= 0) return;
        let cx = this.x - camX;
        let cy = this.y - camY;

        // Chopper Body (Dark Green/Camo)
        ctx.fillStyle = "#2f4f4f";
        drawRoundedRect(ctx, cx, cy, 140, 70, 20);

        // Cockpit
        ctx.fillStyle = "#3498db";
        ctx.beginPath(); ctx.moveTo(cx+10, cy+20); ctx.lineTo(cx+40, cy+20); ctx.lineTo(cx+40, cy+50); ctx.lineTo(cx+15, cy+50); ctx.fill();

        // Rotor
        ctx.fillStyle = "#000";
        ctx.fillRect(cx+60, cy-10, 20, 10);
        // Blade blur
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(cx-20, cy-15, 180, 5);

        // Gun Mount
        ctx.fillStyle = "#111";
        ctx.fillRect(cx+60, cy+70, 30, 10); // Gun
        if (this.timer % 10 < 5) {
             ctx.fillStyle = "yellow"; // Muzzle flash
             ctx.beginPath(); ctx.arc(cx+75, cy+85, 10, 0, Math.PI*2); ctx.fill();
        }

        // Side Doors (Open with Gunner?)
        ctx.fillStyle = "#111";
        ctx.fillRect(cx+80, cy+20, 40, 30);
    }
}

// Expose for testing


// --- player.js ---
class Player {
    constructor() { this.reset(); this.charData = CHARACTERS[0]; }
    setCharacter(typeId) {
        this.charData = CHARACTERS.find(c => c.id === typeId) || CHARACTERS[0];
        if (player) updateUI();
    }
    reset() {
        this.x = gameState.spawnPoint.x; this.y = gameState.spawnPoint.y;
        this.w = 24; this.h = 30; // SLIM FIT HITBOX
        this.vx = 0; this.vy = 0; this.speed = 5;
        this.grounded = false; this.facing = 1; this.health = 3; this.invincible = 0;
        this.stretchX = 1; this.stretchY = 1; this.animFrame = 0;
        this.lastY = this.y;
        this.secondaryCooldown = 0;
        this.attackAnim = { type: null, timer: 0, max: 0 };
        this.wallJumpLocked = false;
    }
    respawn() {
        gameState.lives--; updateUI(); if(gameState.lives <= 0) { endGame(); return; }

        // Pick from unlocked characters
        let unlockedChars = CHARACTERS.slice(0, gameState.globalUnlocked);
        let newCharIndex = Math.floor(secureRandom() * unlockedChars.length);
        this.setCharacter(unlockedChars[newCharIndex].id);

        this.x = gameState.spawnPoint.x; this.y = gameState.spawnPoint.y - 40;
        this.vx = 0; this.vy = 0; this.health = 3; this.invincible = 120;
        spawnExplosion(this.x, this.y, "#00ff41", 2);
    }

    // --- WALL DETECTION ---
    checkWall(dir) {
        if (!tiles) return false;
        let sensorSize = 2; // Check 2 pixels away
        let checkX = dir > 0 ? this.x + this.w + sensorSize : this.x - sensorSize;

        // Check top, middle, and bottom points to ensure we are really next to a wall
        let points = [this.y, this.y + this.h/2, this.y + this.h - 1];

        for (let py of points) {
            let r = Math.floor(py / TILE_SIZE);
            let c = Math.floor(checkX / TILE_SIZE);
            if (r>=0 && r<LEVEL_HEIGHT && c>=0 && c<LEVEL_WIDTH && tiles[r] && tiles[r][c] && (tiles[r][c].type === 1 || tiles[r][c].type === 2)) {
                return true;
            }
        }
        return false;
    }

    update() {
        this.lastY = this.y;
        if(this.secondaryCooldown > 0) this.secondaryCooldown--;
        if(this.attackAnim.timer > 0) this.attackAnim.timer--;

        // FLEX LOGIC
        if (keys['f']) {
            this.vx = 0; // Stop moving
            this.attackAnim = { type: 'flex', timer: 10, max: 10 }; // Keep resetting timer as long as held
            if (gameState.frame % 10 === 0) {
                 spawnDamageNumber(this.x, this.y - 20, "FLEX!", "gold");
                 shakeCamera(2);
            }
            // Optional: Slight heal or invincibility?
            // Let's just make it cool for now.
            // Gravity still applies
            this.vy += GRAVITY;
            this.y += this.vy;
            this.checkCollisions(false);
            return;
        }

        // LADDER CHECK
        let cx = Math.floor((this.x + this.w/2) / TILE_SIZE);
        let cy = Math.floor((this.y + this.h/2) / TILE_SIZE);
        let onLadder = (cy>=0 && cy<LEVEL_HEIGHT && cx>=0 && cx<LEVEL_WIDTH && tiles[cy] && tiles[cy][cx] && tiles[cy][cx].type === 6);

        let input = 0;
        if (keys['arrowleft'] || keys['a']) input = -1;
        if (keys['arrowright'] || keys['d']) input = 1;

        // SECONDARY ATTACK
        if ((keys['c'] || keys['v']) && this.secondaryCooldown <= 0) {
            this.performSecondary();
            this.secondaryCooldown = 30;
        }

        // SPRINT LOGIC
        let isSprinting = keys['shift'];
        this.speed = isSprinting ? 9 : 5;

        // WALL LOGIC
        let wallDir = 0;
        if (this.checkWall(-1)) wallDir = -1;
        if (this.checkWall(1)) wallDir = 1;

        let isWallSliding = false;

        // Must be airborne, pressing against a wall, moving downwards, and pressing INTO the wall
        if (!this.grounded && wallDir !== 0 && input === wallDir && this.vy > 0) {
            isWallSliding = true;

            // Wall Slide Physics (Slow fall)
            if (this.vy > 2) this.vy = 2;

            // Wall Jump Logic
            // We check jump key here directly to override normal jump behavior
            if (keys[' '] && !this.wallJumpLocked) {
                this.vy = JUMP_FORCE;
                this.vx = -wallDir * 10; // Kick off away from wall
                this.wallJumpLocked = true; // Prevent spam
                this.facing = -wallDir; // Face away

                // Visuals
                spawnExplosion(this.x + (wallDir > 0 ? this.w : 0), this.y + this.h/2, C.dirtLight, 0.5);

                // Force exit slide state immediately
                isWallSliding = false;
            }
        }

        // Reset jump lock when key released
        if (!keys[' ']) this.wallJumpLocked = false;

        if (onLadder) {
            this.vy = 0;

            // Allow lateral movement to get off
            if (input !== 0) {
                this.vx = input * 3;
            } else {
                // Smooth snap to center
                let targetX = cx * TILE_SIZE + (TILE_SIZE - this.w) / 2;
                this.vx = (targetX - this.x) * 0.2;
            }

            if (keys['arrowup'] || keys['w']) this.vy = -3;
            if (keys['arrowdown'] || keys['s']) this.vy = 3;

            // Jump
            if (keys[' ']) { this.vy = JUMP_FORCE; }
        } else {
            // Only apply normal physics if NOT wall jumping this frame
            if (!this.wallJumpLocked) {
                if (input !== 0) {
                    this.vx += input * ACCELERATION; this.facing = input;
                    this.animFrame += isSprinting ? 2 : 1;
                    let dustFreq = isSprinting ? 5 : 10;
                    if(this.grounded && this.animFrame % dustFreq === 0) particles.push(new Particle(this.x + 15, this.y + 30, "#d2b48c"));
                } else { this.vx *= FRICTION; this.animFrame = 0; }

                if(Math.abs(this.vx) > this.speed) this.vx = Math.sign(this.vx) * this.speed;
            }

            // Normal Jump
            if (keys[' '] && this.grounded && !isWallSliding) {
                this.vy = JUMP_FORCE; this.grounded = false; this.stretchX = 0.7; this.stretchY = 1.3;
            }

            this.vy += GRAVITY;
            if(this.vy > TERMINAL_VELOCITY) this.vy = TERMINAL_VELOCITY;
        }

        // Dust particles for wall slide
        if (isWallSliding && gameState.frame % 5 === 0) {
             particles.push(new Particle(this.x + (wallDir > 0 ? this.w : 0), this.y + this.h, "#fff"));
        }

        // Apply Shoot Input (Separate from movement)
        if((keys['z'] || keys['j']) && shootCooldown <= 0) {
            let isDown = keys['arrowdown'] || keys['s'];
            let isUp = keys['arrowup'] || keys['w'];
            this.shoot(false, isDown, isUp);
            shootCooldown = 15;
        }
        if((keys['x'] || keys['k']) && specialCooldown <= 0) {
            this.shoot(true, false); specialCooldown = 120;
        }

        this.x += this.vx; this.checkCollisions(true);
        this.y += this.vy; this.checkCollisions(false);
        this.stretchX += (1 - this.stretchX) * 0.1; this.stretchY += (1 - this.stretchY) * 0.1;
        if(this.invincible > 0) this.invincible--;
        if (this.y > (LEVEL_HEIGHT + 5) * TILE_SIZE) this.takeDamage(99);
    }

    checkCollisions(isX) {
        if (!tiles) return;

        let l = Math.floor(this.x / TILE_SIZE);
        let r = Math.floor((this.x + this.w - 0.01) / TILE_SIZE);
        let t = Math.floor(this.y / TILE_SIZE);
        let b = Math.floor((this.y + this.h - 0.01) / TILE_SIZE);

        for(let row = t; row <= b; row++) {
            for(let col = l; col <= r; col++) {
                if(row>=0 && row<LEVEL_HEIGHT && col>=0 && col<LEVEL_WIDTH && tiles[row] && tiles[row][col] && tiles[row][col].type !== 0) {
                    let type = tiles[row][col].type;

                    if(type === 6) continue; // Ignore ladders for solid collision
                    if(type === 4) { this.takeDamage(); return; }
                    if(type === 9) { winGame(); return; }
                    if(type === 5) {
                        if(!tiles[row][col].active) {
                            tiles[row][col].active = true; gameState.checkpointsHit++;
                            gameState.spawnPoint = { x: col * TILE_SIZE, y: (row * TILE_SIZE) - 40 };
                            spawnExplosion(col*TILE_SIZE+20, row*TILE_SIZE+20, "#00ff41", 2);
                            if(this.health < 3) this.health = 3; updateUI();
                        }
                        continue;
                    }
                    if(type === 1 || type === 2) {
                        if(isX) {
                            if(this.vx > 0) {
                                this.x = (col * TILE_SIZE) - this.w;
                                this.vx = 0;
                            } else if (this.vx < 0) {
                                this.x = (col * TILE_SIZE) + TILE_SIZE;
                                this.vx = 0;
                            }
                        } else {
                            if(this.vy > 0) {
                                // Only land if feet were previously above the block
                                if (this.lastY + this.h <= row * TILE_SIZE + 15) {
                                    this.y = (row * TILE_SIZE) - this.h;
                                    this.vy = 0;
                                    if(!this.grounded) { this.stretchX = 1.4; this.stretchY = 0.6; }
                                    this.grounded = true;
                                    return;
                                }
                            } else if (this.vy < 0) {
                                this.y = (row * TILE_SIZE) + TILE_SIZE;
                                this.vy = 0;
                                return;
                            }
                        }
                    }
                }
            }
        }
    }
    takeDamage(amt = 1) {
        if(this.invincible > 0) return;
        this.health -= amt; shakeCamera(15); this.invincible = 60; spawnExplosion(this.x, this.y, "red");
        if(this.health <= 0) this.respawn();
        updateUI();
    }

    performSecondary() {
        let type = this.charData.pType;
        let isMelee = (type === 'melee_slash' || type === 'melee_smash');

        if (isMelee) {
            // Throw Rock/Knife
            entities.push(new Bullet(this.x + 15*this.facing, this.y + 10, this.facing, false, this.charData, false, true)); // isSecondary=true
            this.attackAnim = { type: 'throw', timer: 15, max: 15 };
        } else {
            // Punch/Kick
            entities.push(new MeleeHitbox(this.x + (this.facing===1?0:-40), this.y, 40, 40, this, 1));
            // Visual
            particles.push(new Particle(this.x + (this.facing*20), this.y + 10, "white"));
            this.attackAnim = { type: 'kick', timer: 15, max: 15 };
        }
    }

    shoot(isSpecial, isDown, isUp = false) {
        particles.push(new Particle(this.x + (this.facing*30), this.y + 10, "yellow"));
        shakeCamera(2);

        let type = this.charData.pType;

        if (isSpecial) {
             this.attackAnim = { type: 'punch', timer: 15, max: 15 };
             shakeCamera(10);

             if(this.charData.id === 'raccoon') {
                 entities.push(new Dumpster(this.x, this.y - 100));
             }
             else if (type === 'spread') {
                 // 360 degree shot
                 for(let i=0; i<16; i++) {
                     let angle = (i / 16) * Math.PI * 2;
                     let b = new Bullet(this.x + 15, this.y + 15, this.facing, true, this.charData);
                     b.vx = Math.cos(angle) * 15;
                     b.vy = Math.sin(angle) * 15;
                     entities.push(b);
                 }
             }
             else if (type === 'grenade' || type === 'rocket') {
                 // Cluster
                 for(let i=0; i<3; i++) {
                     let b = new Bullet(this.x + 15 + (15*this.facing), this.y + 15, this.facing, true, this.charData);
                     b.vy = -5 - (i*3);
                     b.vx = this.facing * (10 + i*2);
                     entities.push(b);
                 }
             }
             else if (type === 'melee_smash') {
                 // Shockwave
                 entities.push(new MeleeHitbox(this.x - 100, this.y, 200 + this.w, 60, this, 5));
                 spawnExplosion(this.x, this.y + 30, "white", 3);
                 shakeCamera(20);
             }
             else {
                 // Default special: Bigger, faster bullet
                 let b = new Bullet(this.x + 15 + (15*this.facing), this.y + 15, this.facing, true, this.charData);
                 b.w = 30; b.h = 10; b.vx = this.facing * 30; // High speed
                 entities.push(b);
                 this.vx -= this.facing * 20; // Big recoil
             }
        } else {
            if (isDown) {
                // Downward Attack
                if (type === 'melee_slash' || type === 'melee_smash') {
                    // Ground Smash Hitbox
                    entities.push(new MeleeHitbox(this.x, this.y + this.h, this.w, 40, this, 2));
                    this.vy = -5; // Bounce up
                    this.attackAnim = { type: 'smash_down', timer: 20, max: 20 };
                } else {
                    // Shoot Down
                    entities.push(new Bullet(this.x + this.w/2 - 5, this.y + this.h, this.facing, isSpecial, this.charData, true));
                    this.vy = -2; // Hover
                }
                return;
            }

            if (isUp) {
                // Upward Attack
                if (type === 'melee_slash' || type === 'melee_smash') {
                    // Upward Slash (Anti-air)
                    entities.push(new MeleeHitbox(this.x, this.y - 40, this.w, 40, this, 2));
                    this.attackAnim = { type: 'slash', timer: 15, max: 15 }; // Reuse slash anim
                } else {
                    // Shoot Up
                    entities.push(new Bullet(this.x + this.w/2 - 5, this.y - 20, this.facing, isSpecial, this.charData, false, false, true));
                }
                return;
            }

            if (type === 'melee_slash' || type === 'melee_smash' || type === 'smash') {
                let range = type === 'melee_smash' ? 80 : 50; let power = type === 'melee_smash' ? 3 : 2;
                entities.push(new MeleeHitbox(this.x + (this.facing===1?0:-range), this.y, range, 40, this, power));
                this.attackAnim = { type: 'slash', timer: 15, max: 15 };
            }
            else if (type === 'spread') {
                for(let i=0; i<3; i++) {
                    let b = new Bullet(this.x + 15*this.facing, this.y+10, this.facing, false, this.charData);
                    b.vy = (secureRandom() - 0.5) * 5; entities.push(b);
                }
                this.attackAnim = { type: 'shoot', timer: 10, max: 10 };
            }
            else if (type === 'shuriken') {
                 for(let i=0; i<3; i++) {
                     let b = new Bullet(this.x + 15*this.facing, this.y+10, this.facing, false, this.charData);
                     b.vy = (i - 1) * 2;
                     entities.push(b);
                 }
                 this.attackAnim = { type: 'throw', timer: 10, max: 10 };
            }
            else if (type === 'water_gun') {
                 for(let i=0; i<4; i++) {
                     let b = new Bullet(this.x + 15*this.facing, this.y+10, this.facing, false, this.charData);
                     b.vx = this.facing * (12 + secureRandom() * 4);
                     b.vy = (secureRandom() - 0.5) * 6;
                     entities.push(b);
                 }
                 this.attackAnim = { type: 'shoot', timer: 10, max: 10 };
            }
            else {
                entities.push(new Bullet(this.x + 15 + (15*this.facing), this.y + 15, this.facing, false, this.charData));
                this.attackAnim = { type: 'shoot', timer: 10, max: 10 };
            }
            this.vx -= this.facing * 2;
        }
    }
    draw(ctx, camX, camY) {
        if (this.invincible > 0 && Math.floor(gameState.frame / 4) % 2 === 0) return;
        let cx = this.x - camX + this.w/2;
        let cy = this.y - camY + this.h/2 + (this.h * (1-this.stretchY));

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(this.facing * this.stretchX, this.stretchY);
        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.beginPath(); ctx.ellipse(0, 25, 20, 5, 0, 0, Math.PI*2); ctx.fill();
        drawAnatomicalHero(ctx, this.charData, this.animFrame, this.attackAnim);
        ctx.restore();
    }
}


// --- level.js ---
// --- LEVEL GENERATOR ---
function generateLevel() {
    let newTiles = [];
    let newEntities = [];

    let difficulty = gameState.currentLevel;
    let biome = 'forest';
    if (difficulty >= 3) biome = 'city';
    if (difficulty >= 5) biome = 'volcano';

    // Update global level data for rendering
    gameState.levelData.biome = biome;
    gameState.levelData.difficulty = difficulty;

    // Helper: Spawn Enemy Squad
    function spawnSquad(x, y) {
        let type = secureRandom();
        // Squad Composition based on Difficulty
        if (difficulty >= 3 && type < 0.2) {
             // Specialist Squad: 1 Shield + 2 Grunts
             newEntities.push(new ShieldBearer(x * TILE_SIZE, y * TILE_SIZE));
             newEntities.push(new Enemy((x-1) * TILE_SIZE, y * TILE_SIZE));
             newEntities.push(new Enemy((x+1) * TILE_SIZE, y * TILE_SIZE));
        } else if (difficulty >= 5 && type < 0.3) {
             // Heavy Squad: 1 Heavy + 1 Shield
             newEntities.push(new HeavyGunner(x * TILE_SIZE, (y-1) * TILE_SIZE));
             newEntities.push(new ShieldBearer((x+2) * TILE_SIZE, y * TILE_SIZE));
        } else if (type < 0.4) {
             // Suicide Squad: 3 Kamikazes
             newEntities.push(new KamikazeEnemy(x * TILE_SIZE, y * TILE_SIZE));
             newEntities.push(new KamikazeEnemy((x+1) * TILE_SIZE, y * TILE_SIZE));
             newEntities.push(new KamikazeEnemy((x-1) * TILE_SIZE, y * TILE_SIZE));
        } else {
             // Standard Patrol: 2-3 Grunts
             newEntities.push(new Enemy(x * TILE_SIZE, y * TILE_SIZE));
             newEntities.push(new Enemy((x+1) * TILE_SIZE, y * TILE_SIZE));
             if (secureRandom() < 0.5) newEntities.push(new Enemy((x-1) * TILE_SIZE, y * TILE_SIZE));
        }
    }

    // 1. Init Empty Grid
    for (let r = 0; r < LEVEL_HEIGHT; r++) {
        newTiles[r] = new Array(LEVEL_WIDTH).fill(null).map(() => ({ type: 0 }));
    }

    // 2. Terrain Walker
    let currentHeight = 10;
    let checkpointInterval = Math.floor(LEVEL_WIDTH / 6);
    let nextCheckpoint = checkpointInterval;
    let checkpointsPlaced = 0;
    let beastsPlaced = 0;
    let lastBeastX = -60;
    let lastEncounterX = 0;
    let surfaceMap = [];

    for (let x = 0; x < LEVEL_WIDTH; x++) {

        // Level 20+: Boss Arena at the end
        if (difficulty >= 20 && x > LEVEL_WIDTH - 40) {
            currentHeight = 12;

            // Wall at entrance of arena
            if (x === LEVEL_WIDTH - 40) {
                for(let w=0; w<15; w++) { // High wall
                    if(12-w > 0) newTiles[12-w][x] = { type: 2 };
                }
            }
        }
        else if (x > 15) {
            // Roughness increases with difficulty
            let roughness = 0.2 + (difficulty * 0.05);
            if (secureRandom() < roughness) {
                currentHeight += secureRandom() > 0.5 ? -1 : 1;
            }
            if (currentHeight < 6) currentHeight = 6;
            if (currentHeight > LEVEL_HEIGHT - 10) currentHeight = LEVEL_HEIGHT - 10;

            // Pit Chance (More pits in later levels)
            let pitChance = 0.02 + (difficulty * 0.01);
            if (secureRandom() < pitChance && x > 20) {
                for(let y=0; y<LEVEL_HEIGHT; y++) {
                    if(y >= 0 && y < LEVEL_HEIGHT) newTiles[y][x] = { type: 0 };
                }

                // Lava at bottom for Volcano
                if(biome === 'volcano') {
                     if(LEVEL_HEIGHT-1 < LEVEL_HEIGHT) newTiles[LEVEL_HEIGHT-1][x] = { type: 4, color: "#e74c3c" }; // Lava
                } else {
                     if(LEVEL_HEIGHT-1 < LEVEL_HEIGHT) newTiles[LEVEL_HEIGHT-1][x] = { type: 4, color: "#999" }; // Spikes
                }

                surfaceMap[x] = LEVEL_HEIGHT + 10;

                // Bridge?
                if (secureRandom() < 0.5) {
                    newEntities.push(new BridgeBlock(x * TILE_SIZE, (currentHeight-1) * TILE_SIZE));
                }

                continue;
            }

            // DECIDE RESCUE TYPE (Broforce: Often on high ground/cages)
            // Increase frequency (beastsPlaced < 8) and reduce distance check (30)
            if (beastsPlaced < 8 && (x - lastBeastX > 30) && secureRandom() < 0.08) {
                // Place directly on ground
                let groundY = currentHeight - 1;
                if (groundY > 0) {
                     newEntities.push(new TrappedBeast(x * TILE_SIZE, groundY * TILE_SIZE));
                     beastsPlaced++;
                     lastBeastX = x;
                     // Guard Squad
                     spawnSquad(x + 2, groundY);
                }
            }
        }
        else {
            currentHeight = 10;
        }

        surfaceMap[x] = currentHeight;

        // Fill Column
        for (let y = 0; y < LEVEL_HEIGHT; y++) {
            if (y >= currentHeight) {
                let type = 1; // Dirt
                if (x < 15 || (difficulty >= 20 && x > LEVEL_WIDTH - 40)) type = 2; // Stone safe zones / Arena floor
                else if (y >= LEVEL_HEIGHT - 2) type = 2; // Bedrock
                newTiles[y][x] = { type: type };
            }
        }
    }

    // 3. PASS 2: UNDERGROUND TUNNEL NETWORK
    for (let x = 40; x < LEVEL_WIDTH - 60; x += 40) {
        if (secureRandom() < 0.7 && surfaceMap[x] < LEVEL_HEIGHT - 15) {
            let startY = surfaceMap[x];
            let bottomY = LEVEL_HEIGHT - 5;

            // 1. Vertical Ladder Shaft
            for (let y = startY; y < bottomY; y++) {
                if (y >= 0 && y < LEVEL_HEIGHT) newTiles[y][x] = { type: 6 };
            }

            // 2. Horizontal Tunnels
            let numTunnels = Math.floor(secureRandom() * 3) + 2;
            for (let i = 0; i < numTunnels; i++) {
                let tunnelY = startY + 10 + Math.floor(secureRandom() * (bottomY - startY - 15));
                let tunnelLen = 10 + Math.floor(secureRandom() * 15);
                let dir = secureRandom() > 0.5 ? 1 : -1;

                for (let j = 0; j < tunnelLen; j++) {
                    let tx = x + (j * dir);
                    for (let ty = tunnelY; ty < tunnelY + 3; ty++) {
                        if (ty >= 0 && ty < LEVEL_HEIGHT && tx >= 0 && tx < LEVEL_WIDTH) {
                            newTiles[ty][tx] = { type: 0 };
                        }
                    }

                    // Enemies in tunnels (Ambush style)
                    if (secureRandom() < 0.1 && j > 5 && (j % 5 === 0)) {
                        let rand = secureRandom();
                        if (difficulty >= 3 && rand < 0.3) newEntities.push(new KamikazeEnemy(tx * TILE_SIZE, (tunnelY + 2) * TILE_SIZE));
                        else newEntities.push(new Enemy(tx * TILE_SIZE, (tunnelY + 2) * TILE_SIZE));
                    }

                    // Hostage Check (Hidden in caves)
                    if (beastsPlaced < 8 && (tx - lastBeastX > 30 || lastBeastX - tx > 30) && secureRandom() < 0.05) {
                        let beastY = tunnelY;
                        if (beastY > 0 && newTiles[beastY-1][tx].type !== 0) {
                            newTiles[beastY-1][tx] = { type: 1 };
                            newEntities.push(new TrappedBeast(tx * TILE_SIZE, (beastY + 1) * TILE_SIZE, beastY-1, tx));
                            beastsPlaced++;
                            lastBeastX = tx;
                            // Cave Guard
                            newEntities.push(new HeavyGunner((tx+2) * TILE_SIZE, (beastY + 1) * TILE_SIZE));
                        }
                    }
                }
            }
        }
    }

    // 4. PASS 3: SURFACE OBJECTS & FLOATING ISLANDS
    checkpointsPlaced = 0;
    nextCheckpoint = Math.floor(LEVEL_WIDTH / 6);
    lastEncounterX = 20;

    for (let x = 20; x < LEVEL_WIDTH - 40; x++) {
        let y = surfaceMap[x];
        if (y >= LEVEL_HEIGHT) continue;

        // Checkpoints (Scarcer in hard levels)
        let cpReq = checkpointsPlaced < 5;
        if (difficulty >= 5 && checkpointsPlaced >= 3) cpReq = false;

        if (x >= nextCheckpoint && cpReq) {
            newTiles[y][x] = { type: 2 };
            newTiles[y-1][x] = { type: 5, active: false, id: checkpointsPlaced };
            nextCheckpoint += Math.floor(LEVEL_WIDTH / (difficulty >= 5 ? 4 : 6));
            checkpointsPlaced++;

            // Checkpoints are safe zones, no enemies *directly* on them usually
            // Spawn Mech nearby occasionally
            if (difficulty >= 2 && secureRandom() < 0.3) {
                 newEntities.push(new MechSuit((x+2) * TILE_SIZE, (y-3) * TILE_SIZE));
            }
        }
        else if (secureRandom() < 0.03 + (difficulty*0.01)) {
            if (newTiles[y-1][x].type === 0) newEntities.push(new PropaneTank(x * TILE_SIZE, (y-1) * TILE_SIZE));
        }

        // ENEMY ENCOUNTERS (Clusters)
        // Spawn a squad every ~15-25 tiles, with some randomness
        if (x - lastEncounterX > (15 - difficulty)) { // More frequent in hard levels
             if (secureRandom() < 0.4) {
                 spawnSquad(x, y-1);
                 lastEncounterX = x;
             }
        }

        // Occasional Sniper on high ground or random flyer
        if (secureRandom() < 0.02) {
             if (difficulty >= 2) newEntities.push(new SniperEnemy(x * TILE_SIZE, (y-1) * TILE_SIZE));
        }
        if (secureRandom() < 0.02) newEntities.push(new FlyingEnemy(x * TILE_SIZE, (y-5) * TILE_SIZE));
    }

    // 5. FINISH
    for(let y=0; y<LEVEL_HEIGHT; y++) {
        newTiles[y][0] = { type: 2 };
        newTiles[y][LEVEL_WIDTH-1] = { type: 2 };
    }

    // Boss Spawning Logic
    if (difficulty < 20) {
         // Spawn Boss in normal terrain (Last 30% of map)
         let spawnRangeStart = Math.floor(LEVEL_WIDTH * 0.7);
         let bossX = spawnRangeStart + Math.floor(secureRandom() * (LEVEL_WIDTH - spawnRangeStart - 5));

         // Find ground Y
         let bossY = 10;
         if (surfaceMap[bossX]) bossY = surfaceMap[bossX] - 5;

         // Safety check
         if (bossY > LEVEL_HEIGHT - 5) bossY = 10;

         let bossType = (difficulty >= 4 && difficulty % 2 === 0) ? 'heli' : 'ground';

         if (bossType === 'heli') {
             newEntities.push(new HelicopterBoss(bossX * TILE_SIZE, (bossY - 10) * TILE_SIZE));
         } else {
             newEntities.push(new Boss(bossX * TILE_SIZE, bossY * TILE_SIZE));
         }

         // Boss Entourage
         spawnSquad(bossX - 5, bossY);
         spawnSquad(bossX + 5, bossY);

    } else {
         // Level 20+: Special Room
         // Boss is in the arena at the end
         newEntities.push(new Boss((LEVEL_WIDTH - 20) * TILE_SIZE, 8 * TILE_SIZE));

         // Traps/Turrets in arena?
         newEntities.push(new HeavyGunner((LEVEL_WIDTH - 35) * TILE_SIZE, 8 * TILE_SIZE));
         newEntities.push(new HeavyGunner((LEVEL_WIDTH - 5) * TILE_SIZE, 8 * TILE_SIZE));
    }

    entities = newEntities;
    return newTiles;
}
window.generateLevel = generateLevel;


// --- render.js ---
// --- RENDERING ---

function drawRoundedRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
}

function drawCartoonEye(ctx, x, y, size, lookX, lookY) {
    ctx.fillStyle = "#fff";
    ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#000"; ctx.lineWidth = 1; ctx.stroke();

    // Pupil
    let pupilSize = size * 0.4;
    let px = x + lookX * (size * 0.3);
    let py = y + lookY * (size * 0.3);
    ctx.fillStyle = "#000";
    ctx.beginPath(); ctx.arc(px, py, pupilSize, 0, Math.PI*2); ctx.fill();

    // Shine
    ctx.fillStyle = "#fff";
    ctx.beginPath(); ctx.arc(px + pupilSize*0.3, py - pupilSize*0.3, pupilSize*0.3, 0, Math.PI*2); ctx.fill();
}

function drawBackground(ctx, camX, camY) {
    let grd = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
    grd.addColorStop(0, C.skyTop);
    grd.addColorStop(1, C.skyBot);
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Simple Moon
    ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    ctx.beginPath();
    ctx.arc(ctx.canvas.width - 100, 100, 50, 0, Math.PI*2);
    ctx.fill();
}

function drawHeroHead(ctx, char) {
    let skin = char.cSkin;
    let dark = char.cDark;

    ctx.fillStyle = skin;

    // 1. EARS / BASE HEAD
    if (['dog_pointy', 'wolf', 'fox', 'cat', 'monkey', 'bat'].includes(char.type)) {
        drawRoundedRect(ctx, -12, -12, 24, 20, 8);
        if (char.type === 'monkey') {
            // Monkey Ears
            ctx.beginPath(); ctx.arc(-14, -5, 5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(14, -5, 5, 0, Math.PI*2); ctx.fill();
        } else if (char.type === 'bat') {
            // Bat Ears
             ctx.beginPath(); ctx.moveTo(-8, -12); ctx.lineTo(-18, -25); ctx.lineTo(-2, -12); ctx.fill();
             ctx.beginPath(); ctx.moveTo(8, -12); ctx.lineTo(18, -25); ctx.lineTo(2, -12); ctx.fill();
        } else {
            // Pointy Ears
            ctx.beginPath(); ctx.moveTo(-8, -10); ctx.lineTo(-14, -22); ctx.lineTo(-2, -10); ctx.fill();
            ctx.beginPath(); ctx.moveTo(8, -10); ctx.lineTo(14, -22); ctx.lineTo(2, -10); ctx.fill();
        }
    }
    else if (['dog_flat', 'pig', 'bear', 'poodle', 'dog_long', 'panda', 'koala', 'lion'].includes(char.type)) {
        drawRoundedRect(ctx, -12, -12, 24, 20, 8);
        // Floppy/Round Ears
        ctx.beginPath(); ctx.arc(-12, -6, 6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(12, -6, 6, 0, Math.PI*2); ctx.fill();
    }
    else if (char.type === 'rabbit' || char.type === 'kangaroo') {
        drawRoundedRect(ctx, -10, -10, 20, 18, 5);
        ctx.fillStyle = skin;
        drawRoundedRect(ctx, -8, -32, 6, 24, 3);
        drawRoundedRect(ctx, 2, -32, 6, 24, 3);
    }
    else if (['rodent', 'hedgehog', 'skunk', 'anteater'].includes(char.type)) {
        drawRoundedRect(ctx, -10, -8, 20, 16, 6); // Smaller head
        ctx.beginPath(); ctx.arc(-8, -6, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(8, -6, 4, 0, Math.PI*2); ctx.fill();
    }
    else if (['rhino', 'elephant', 'cow'].includes(char.type)) {
        drawRoundedRect(ctx, -14, -14, 28, 24, 8); // Big head
        if(char.type === 'cow') {
            // Horns
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.moveTo(-14, -10); ctx.quadraticCurveTo(-20, -20, -10, -15); ctx.fill();
            ctx.beginPath(); ctx.moveTo(14, -10); ctx.quadraticCurveTo(20, -20, 10, -15); ctx.fill();
            ctx.fillStyle = skin;
        } else {
            ctx.beginPath(); ctx.arc(-14, -4, 8, 0, Math.PI*2); ctx.fill(); // Ears
        }
    }
    else if (['bird', 'duck', 'chicken', 'penguin'].includes(char.type)) {
        ctx.beginPath(); ctx.arc(0, -5, 12, 0, Math.PI*2); ctx.fill();
    }
    else if (['raccoon', 'panda'].includes(char.type)) {
        drawRoundedRect(ctx, -11, -10, 22, 18, 6);
        ctx.beginPath(); ctx.moveTo(-9, -8); ctx.lineTo(-13, -18); ctx.lineTo(-3, -8); ctx.fill();
        ctx.beginPath(); ctx.moveTo(9, -8); ctx.lineTo(13, -18); ctx.lineTo(3, -8); ctx.fill();
    }
    else if (['turtle', 'frog', 'fish', 'alien', 'skeleton', 'pumpkin', 'robot', 'stone'].includes(char.type)) {
        if(char.type === 'turtle' || char.type === 'frog') {
             drawRoundedRect(ctx, -12, -10, 24, 16, 8); // Flat head
             if(char.type === 'frog') {
                 // Bug eyes
                 ctx.beginPath(); ctx.arc(-8, -12, 5, 0, Math.PI*2); ctx.fill();
                 ctx.beginPath(); ctx.arc(8, -12, 5, 0, Math.PI*2); ctx.fill();
             }
        }
        else if (char.type === 'fish') {
             // Fish shape
             ctx.beginPath(); ctx.ellipse(0, -5, 12, 15, Math.PI/2, 0, Math.PI*2); ctx.fill();
             // Fin
             ctx.beginPath(); ctx.moveTo(0, -18); ctx.lineTo(-5, -5); ctx.lineTo(5, -5); ctx.fill();
        }
        else if (char.type === 'alien') {
             // Alien Head
             ctx.beginPath(); ctx.moveTo(0, 10); ctx.bezierCurveTo(20, 0, 20, -30, 0, -30); ctx.bezierCurveTo(-20, -30, -20, 0, 0, 10); ctx.fill();
        }
        else if (char.type === 'skeleton') {
             // Skull
             ctx.fillStyle = "#eee";
             drawRoundedRect(ctx, -10, -15, 20, 20, 8);
             ctx.fillRect(-6, 5, 12, 6); // Jaw
        }
        else if (char.type === 'pumpkin') {
             ctx.fillStyle = "#FFA500";
             ctx.beginPath(); ctx.arc(0, -5, 14, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = "#006400"; ctx.fillRect(-2, -22, 4, 8); // Stem
        }
        else if (char.type === 'robot') {
             drawRoundedRect(ctx, -12, -15, 24, 24, 2); // Square
             // Antenna
             ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(0, -25); ctx.stroke();
             ctx.beginPath(); ctx.arc(0, -25, 3, 0, Math.PI*2); ctx.fill();
        }
        else if (char.type === 'stone') {
             // Rock shape
             ctx.beginPath();
             ctx.moveTo(-10, -15); ctx.lineTo(5, -20); ctx.lineTo(12, -10); ctx.lineTo(10, 5); ctx.lineTo(-8, 8);
             ctx.fill();
        }
    }
    else {
        // Generic / Human
        drawRoundedRect(ctx, -11, -11, 22, 22, 8);
    }

    // 2. FACE DETAILS
    if (char.type === 'raccoon' || char.type === 'panda') {
        ctx.fillStyle = (char.type === 'panda') ? "#000" : "#333";
        ctx.beginPath(); ctx.ellipse(-5, -4, 4, 5, 0.2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(5, -4, 4, 5, -0.2, 0, Math.PI*2); ctx.fill();
    }

    // Snouts
    if (['dog_pointy', 'dog_flat', 'dog_long', 'wolf', 'fox', 'bear', 'pig', 'monkey', 'cow'].includes(char.type)) {
        ctx.fillStyle = dark;
        if(char.type === 'pig') {
             ctx.fillStyle = "#ffb6c1";
             drawRoundedRect(ctx, -6, 0, 12, 8, 3);
             ctx.fillStyle = "#d16d7e";
             ctx.beginPath(); ctx.arc(-3, 4, 2, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(3, 4, 2, 0, Math.PI*2); ctx.fill();
        } else if (char.type === 'monkey') {
             ctx.fillStyle = "#FFE4C4"; // Face color
             ctx.beginPath(); ctx.ellipse(0, 2, 8, 6, 0, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = "#000"; ctx.beginPath(); ctx.moveTo(-2, 0); ctx.lineTo(2, 0); ctx.stroke();
        } else if (char.type === 'cow') {
             ctx.fillStyle = "#FFC0CB";
             drawRoundedRect(ctx, -7, 0, 14, 8, 3);
        } else {
             drawRoundedRect(ctx, -6, -1, 12, 9, 4);
             ctx.fillStyle = "#000";
             ctx.beginPath(); ctx.arc(0, -1, 3, 0, Math.PI*2); ctx.fill(); // Nose
        }
    }
    else if (['cat', 'panther', 'raccoon', 'lion', 'bat'].includes(char.type)) {
        ctx.fillStyle = "#000";
        ctx.beginPath(); ctx.moveTo(-2, 2); ctx.lineTo(2, 2); ctx.lineTo(0, 5); ctx.fill(); // Tiny nose
        // Whiskers
        ctx.strokeStyle = "#000"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(5, 0); ctx.lineTo(15, -2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(5, 2); ctx.lineTo(15, 4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-5, 0); ctx.lineTo(-15, -2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-5, 2); ctx.lineTo(-15, 4); ctx.stroke();
    }
    else if (char.type === 'elephant') {
        ctx.lineWidth = 6; ctx.strokeStyle = skin; ctx.lineCap = "round";
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(0, 15, 10, 10); ctx.stroke();
    }
    else if (char.type === 'rhino') {
        ctx.fillStyle = "#eee";
        ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(4, -15); ctx.lineTo(6, -5); ctx.fill();
    }
    else if (['bird', 'duck', 'chicken', 'penguin'].includes(char.type)) {
        ctx.fillStyle = "orange";
        if(char.type === 'duck' || char.type === 'chicken') {
            ctx.beginPath(); ctx.ellipse(0, -2, 8, 4, 0, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.beginPath(); ctx.moveTo(5, -5); ctx.lineTo(18, -2); ctx.lineTo(5, 2); ctx.fill();
        }
    }
    else if (char.type === 'anteater') {
        ctx.fillStyle = dark;
        ctx.beginPath(); ctx.moveTo(8, 0); ctx.lineTo(20, 2); ctx.lineTo(8, 6); ctx.fill();
    }
    else if (char.type === 'croc' || char.type === 'lizard') {
        ctx.fillStyle = dark;
        drawRoundedRect(ctx, -8, 0, 16, 12, 4); // Snout
    }
    else if (char.type === 'skeleton') {
         ctx.fillStyle = "#000";
         ctx.beginPath(); ctx.arc(-5, -6, 3, 0, Math.PI*2); ctx.fill();
         ctx.beginPath(); ctx.arc(5, -6, 3, 0, Math.PI*2); ctx.fill();
         ctx.beginPath(); ctx.moveTo(0, 2); ctx.lineTo(-2, 6); ctx.lineTo(2, 6); ctx.fill(); // Nose hole
    }
    else if (char.type === 'pumpkin') {
         ctx.fillStyle = "#000";
         ctx.beginPath(); ctx.moveTo(-6, -6); ctx.lineTo(-2, -2); ctx.lineTo(-10, -2); ctx.fill(); // Eye
         ctx.beginPath(); ctx.moveTo(6, -6); ctx.lineTo(2, -2); ctx.lineTo(10, -2); ctx.fill(); // Eye
         ctx.beginPath(); ctx.moveTo(-8, 5); ctx.lineTo(0, 8); ctx.lineTo(8, 5); ctx.fill(); // Mouth
    }
    else if (char.type === 'robot') {
         ctx.fillStyle = "#00FF00";
         ctx.fillRect(-8, -10, 5, 5); ctx.fillRect(3, -10, 5, 5); // Square eyes
         ctx.fillRect(-6, 2, 12, 2); // Mouth slot
    }

    // 3. EYES
    if (['skeleton', 'pumpkin', 'robot', 'alien'].includes(char.type)) {
        // Eyes already drawn in base head or specialized logic
    } else if(char.name.includes("DARE")) {
        ctx.fillStyle = char.cDark;
        ctx.fillRect(-12, -8, 24, 6);
    } else if (char.name.includes("SPIDER") || char.name.includes("DEAD") || char.name.includes("PANTHER") || char.name.includes("IRON")) {
        // Mask Eyes
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.ellipse(-5, -4, 4, 6, -0.2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(5, -4, 4, 6, 0.2, 0, Math.PI*2); ctx.fill();
        // Outline
        ctx.strokeStyle = "#000"; ctx.lineWidth = 1; ctx.stroke();
    } else {
        // Cartoon Eyes
        drawCartoonEye(ctx, -5, -4, 4, 0.5, 0);
        drawCartoonEye(ctx, 5, -4, 4, 0.5, 0);
    }

    // 4. HATS / SPECIAL
    if(char.name.includes("CAP") || char.name.includes("TRASH")) {
        // Cap
        ctx.fillStyle = char.cSuit;
        ctx.beginPath(); ctx.arc(0, -11, 12, Math.PI, 0); ctx.fill();
        ctx.fillRect(-12, -11, 24, 2);
    }
    if(char.type === 'tree') {
         ctx.fillStyle = "lime";
         ctx.beginPath(); ctx.arc(0, -15, 8, 0, Math.PI*2); ctx.fill();
    }
}

function drawAnatomicalHero(ctx, char, frame, attackAnim = null) {
    let skin = char.cSkin;
    let dark = char.cDark;
    let suit = char.cSuit;

    // Animation
    let bob = Math.sin(frame * 0.5) * 2;
    let runCycle = Math.sin(frame * 0.5);
    let legAngle = runCycle * 0.8;
    let armAngle = -runCycle * 0.8;

    let armOffsetX = 0;
    let armOffsetY = 0;
    let legOffsetX = 0;
    let legOffsetY = 0;

    if (attackAnim && attackAnim.timer > 0) {
        let t = attackAnim.timer / attackAnim.max;
        let p = Math.sin(t * Math.PI);

        if (attackAnim.type === 'kick') {
            legAngle = -Math.PI/2 * p; // Kick Up
            legOffsetX = p * 10;
            armAngle = Math.PI/4; // Balance
        } else if (attackAnim.type === 'punch' || attackAnim.type === 'shoot') {
             armAngle = -Math.PI/2;
             armOffsetX = p * 15;
        } else if (attackAnim.type === 'slash') {
             armAngle = -Math.PI/2 + (t * Math.PI) - Math.PI/2; // Downward slash arc
        } else if (attackAnim.type === 'smash_down') {
             armAngle = Math.PI;
             if(t < 0.5) armAngle = 0; // Wind up then smash
        } else if (attackAnim.type === 'throw') {
             armAngle = -Math.PI/2 + (1-t) * Math.PI;
        } else if (attackAnim.type === 'flex') {
             // Bicep Flex
             armAngle = -Math.PI + 0.5; // Up
             armOffsetX = -5;
             bob = Math.sin(frame * 1.5) * 3; // Intense bobbing
        }
    }

    let isBulky = ['rhino', 'elephant', 'bear', 'poodle', 'tree'].includes(char.type);
    let isSmall = ['rodent', 'hedgehog', 'rabbit', 'pig'].includes(char.type);

    let scale = isSmall ? 0.8 : (isBulky ? 1.2 : 1.0);

    ctx.save();
    ctx.scale(scale, scale);

    // CAPE
    if (['dog_pointy', 'cat', 'bird'].includes(char.type) || char.name.includes("SUPER") || char.name.includes("THOR") || char.name.includes("STRANGE") || char.name.includes("SCARLET") || char.name.includes("VISION")) {
         ctx.fillStyle = char.pColor;
         ctx.beginPath();
         ctx.moveTo(-10, 5 + bob);
         ctx.lineTo(10, 5 + bob);
         ctx.lineTo(15 + Math.sin(frame*0.2)*5, 35 + bob);
         ctx.lineTo(-15 + Math.sin(frame*0.2+1)*5, 35 + bob);
         ctx.fill();
    }

    // TAIL
    if (['dog_pointy', 'dog_flat', 'dog_long', 'cat', 'fox', 'wolf', 'panther', 'raccoon', 'monkey', 'lizard', 'croc', 'cow', 'lion', 'fish'].includes(char.type)) {
        ctx.strokeStyle = skin;
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(-5, 25 + bob);
        if(char.type === 'monkey') {
            ctx.quadraticCurveTo(-20, 10 + bob, -5, 5 + bob); // Curly tail
        } else if (char.type === 'fish') {
            ctx.moveTo(0, 25+bob); ctx.lineTo(0, 35+bob); // Fish tail
        } else {
            ctx.quadraticCurveTo(-15, 20 + bob + Math.sin(frame*0.3)*5, -20, 15 + bob);
        }
        ctx.stroke();
        if(char.type === 'raccoon') { // Striped tail
             ctx.strokeStyle = "#333"; ctx.lineWidth=4; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.setLineDash([]);
        }
    }
    if (char.type === 'turtle') {
        // Shell
        ctx.fillStyle = dark;
        ctx.beginPath(); ctx.arc(0, 15+bob, 14, 0, Math.PI*2); ctx.fill();
    }

    // BACK LEG
    ctx.fillStyle = dark;
    ctx.save();
    ctx.translate(-4, 25 + bob);
    ctx.rotate(legAngle);
    drawRoundedRect(ctx, -3, 0, 6, 12, 3);
    ctx.restore();

    // BODY
    ctx.fillStyle = suit;
    let bw = isBulky ? 26 : 20;
    let bh = isBulky ? 22 : 18;
    drawRoundedRect(ctx, -bw/2, 8 + bob, bw, bh, 5);

    // CHEST DETAIL
    ctx.fillStyle = "rgba(255,255,255,0.3)";
    ctx.beginPath(); ctx.arc(0, 16+bob, 4, 0, Math.PI*2); ctx.fill();

    // BELT
    ctx.fillStyle = "#FFD700";
    ctx.fillRect(-bw/2, 22 + bob, bw, 4);

    // HEAD
    ctx.save();
    ctx.translate(0, 0 + bob);
    drawHeroHead(ctx, char);
    ctx.restore();

    // FRONT LEG (ANIMATED FOR KICK)
    ctx.fillStyle = dark;
    ctx.save();
    ctx.translate(4 + legOffsetX, 25 + bob + legOffsetY);
    // If kicking, override rotation logic. Otherwise use run cycle.
    if(attackAnim && attackAnim.type === 'kick' && attackAnim.timer > 0) {
        ctx.rotate(legAngle); // legAngle is calculated in attack block
    } else {
        ctx.rotate(-legAngle); // Normal run cycle (opposite of back leg)
    }
    drawRoundedRect(ctx, -3, 0, 6, 12, 3);
    ctx.restore();

    // FRONT ARM (ANIMATED)
    ctx.fillStyle = suit;
    ctx.save();
    ctx.translate(0 + armOffsetX, 15 + bob + armOffsetY);
    ctx.rotate(armAngle);
    drawRoundedRect(ctx, -3, 0, 6, 12, 3);
    // Hand
    ctx.fillStyle = skin;
    ctx.beginPath(); ctx.arc(0, 12, 4, 0, Math.PI*2); ctx.fill();
    // Weapon/Prop
    if(char.pType === 'boomerang') {
         ctx.fillStyle = char.pColor;
         ctx.translate(0, 12); ctx.rotate(Math.PI/2);
         ctx.fillRect(-2, -6, 4, 12);
    }
    ctx.restore();

    ctx.restore();
}

// VISUALS: MENU
function drawMenu() {
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Safety reset
    ctx.clearRect(0,0,canvas.width,canvas.height);
    var grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grd.addColorStop(0, "#111"); grd.addColorStop(1, "#333");
    ctx.fillStyle = grd; ctx.fillRect(0,0,canvas.width,canvas.height);
}

function drawRoster() {
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Safety reset
    ctx.clearRect(0,0,canvas.width,canvas.height);
    var grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grd.addColorStop(0, "#111"); grd.addColorStop(1, "#333");
    ctx.fillStyle = grd; ctx.fillRect(0,0,canvas.width,canvas.height);

    let padding = 70;
    let cols = 12; // More columns
    let totalWidth = cols * padding;
    let startX = (canvas.width - totalWidth) / 2 + padding/2;
    let startY = 100;

    // Scale down if screen is small
    let scale = 1;
    if (totalWidth > canvas.width) scale = canvas.width / (totalWidth + 50);

    ctx.save();
    ctx.scale(scale, scale);
    if(scale < 1) startX = (canvas.width/scale - totalWidth)/2 + padding/2;

    ctx.font = "30px 'Courier New'";
    ctx.fillStyle = "#00ff41";
    ctx.textAlign = "center";
    ctx.fillText("ROSTER STATUS: " + gameState.globalUnlocked + " / " + CHARACTERS.length + " HEROES UNLOCKED", (canvas.width/scale)/2, 50);

    for(let i=0; i<CHARACTERS.length; i++) {
        let row = Math.floor(i / cols);
        let col = i % cols;
        let cx = startX + col * padding;
        let cy = startY + row * padding;

        ctx.fillStyle = "rgba(255,255,255,0.1)";
        drawRoundedRect(ctx, cx-30, cy-30, 60, 60, 10);

        if (i < gameState.globalUnlocked) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(0.8, 0.8);
            let frame = Date.now() / 100;
            drawAnatomicalHero(ctx, CHARACTERS[i], frame);
            ctx.restore();

            ctx.fillStyle = "#aaa"; ctx.font = "8px Arial";
            ctx.fillText(CHARACTERS[i].name.split(" ")[0], cx, cy+40);
        } else {
            ctx.fillStyle = "#222";
            ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI*2); ctx.fill();

            let needed = i - gameState.globalUnlocked + 1;
            ctx.fillStyle = "#555";
            if (needed === 1) {
                ctx.font = "10px Arial"; ctx.fillText("NEXT", cx, cy-5);
                ctx.font = "bold 16px Arial"; ctx.fillStyle = "#00ff41"; ctx.fillText("1", cx, cy+12);
            } else {
                ctx.font = "16px Arial"; ctx.fillText(needed, cx, cy+6);
            }
        }
    }
    ctx.restore();
}


// --- main.js ---
// --- SYSTEM FUNCTIONS ---

function updateUI() {
    if (!player) return;
    let hearts = "‚ù§".repeat(Math.max(0, player.health));
    document.getElementById('healthDisplay').innerText = hearts;
    document.getElementById('scoreDisplay').innerText = gameState.score;
    document.getElementById('rescueDisplay').innerText = gameState.rescues;
    document.getElementById('livesDisplay').innerText = gameState.lives;
    document.getElementById('levelDisplay').innerText = gameState.currentLevel;
    let charName = player.charData ? player.charData.name : "UNKNOWN";
    document.getElementById('charName').innerText = charName;
    if(player.charData) document.getElementById('charName').style.color = player.charData.cSkin;
}

function winGame() {
    gameState.running = false;
    // Calculate Stats
    gameState.levelCompleteStats.kills = 0; // Todo: Track kills properly in state?
    // Simplified: Score / 100 roughly
    let kills = Math.floor((gameState.score - (gameState.rescues * 500)) / 100);
    if (kills < 0) kills = 0;

    document.getElementById('lcKills').innerText = kills;
    document.getElementById('lcRescues').innerText = gameState.rescues;
    document.getElementById('lcTime').innerText = Math.floor((10000 - gameState.frame)/60); // Bonus

    document.getElementById('levelCompleteOverlay').style.display = 'flex';
}

function endGame() {
    gameState.running = false;
    document.getElementById('ovTitle').innerText = "MISSION FAILED";
    document.getElementById('ovTitle').style.color = "red";
    document.getElementById('ovMsg').innerText = "Out of lives. The pound awaits.";
    document.getElementById('gameOverOverlay').style.display = 'flex';
}

// FRAMERATE CAP

function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaTime = timestamp - lastTime;

    // Slow Motion Logic
    let interval = INTERVAL / gameState.slowMo;

    if (deltaTime < interval) {
        requestAnimationFrame(loop);
        return;
    }
    lastTime = timestamp - (deltaTime % interval);

    // DEBUG UPDATE
    try {
        if (debugHUD) {
            debugHUD.textContent =
                `State: ${gameState.screen}\n` +
                `Run: ${gameState.running}\n` +
                `Level: ${gameState.currentLevel}\n` +
                `Biome: ${gameState.levelData.biome}\n` +
                `Ents: ${entities.length}\n` +
                `FPS: ${Math.round(1000/deltaTime)}`;
        }
    } catch(e) {}

    // 1. UPDATE LOOP (Logic)
    try {
        if(gameState.screen === 'MENU' || gameState.screen === 'ROSTER') {
            // No logic update needed for menus in this simple game
        } else if (gameState.running) {
            if(gameState.hitStop > 0) {
                gameState.hitStop--;
            } else {
                gameState.frame++;
                if(player) player.update();

                if(shootCooldown > 0) shootCooldown--;
                if(specialCooldown > 0) specialCooldown--;


                entities = entities.filter(e => (e.hp > 0) || (e.life > 0));
                entities.forEach(e => e.update());

                particles = particles.filter(p => p.life > 0); particles.forEach(p => p.update());
                damageNumbers = damageNumbers.filter(d => d.life > 0);
                damageNumbers.forEach(d => { d.y += d.vy; d.life--; });
                debris = debris.filter(d => d.life > 0); debris.forEach(d => d.update());
            }

            if (player) {
                let targetX = player.x - canvas.width * 0.3; if(targetX < 0) targetX = 0;
                if(gameState.bossActive) { let bossArenaX = (LEVEL_WIDTH - 25) * TILE_SIZE; if(targetX < bossArenaX) targetX = bossArenaX; }
                gameState.cameraX += (targetX - gameState.cameraX) * 0.1;
                let targetY = player.y - canvas.height * 0.5; if (targetY < 0) targetY = 0;
                gameState.cameraY += (targetY - gameState.cameraY) * 0.1;
            }

            let sx = (secureRandom()-0.5) * gameState.shake;
            let sy = (secureRandom()-0.5) * gameState.shake;
            gameState.shake *= 0.9;
        }
    } catch(e) {
        console.error("Game Loop Update Error:", e);
        // Explicitly call onerror to show in overlay
        window.onerror(e.message, "loajf.html (Update Loop)", 0, 0, e);
    }

    // 2. DRAW LOOP (Rendering)
    try {
        if(gameState.screen === 'MENU') {
            drawMenu();
        } else if(gameState.screen === 'ROSTER') {
            drawRoster();
        } else {
            // GAME DRAW
            let sx = (secureRandom()-0.5) * gameState.shake;
            let sy = (secureRandom()-0.5) * gameState.shake;

            ctx.setTransform(1, 0, 0, 1, 0, 0); // Safety reset
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Background based on Biome
            drawBackground(ctx, gameState.cameraX + sx, gameState.cameraY + sy);

            ctx.save();
            ctx.translate(-gameState.cameraX + sx, -gameState.cameraY + sy);

            let startCol = Math.floor(gameState.cameraX / TILE_SIZE); let endCol = startCol + (canvas.width / TILE_SIZE) + 4;
            let startRow = Math.floor(gameState.cameraY / TILE_SIZE); let endRow = startRow + (canvas.height / TILE_SIZE) + 4;

            for(let r=startRow; r<endRow && r<LEVEL_HEIGHT; r++) {
                for(let c=startCol; c<endCol && c<LEVEL_WIDTH; c++) {
                    if(tiles && tiles[r] && tiles[r][c] && tiles[r][c].type !== 0) {
                        let t = tiles[r][c]; let tx = c*TILE_SIZE; let ty = r*TILE_SIZE;

                        if(t.type === 6) {
                            ctx.fillStyle = C.ladder;
                            ctx.fillRect(tx + 10, ty, 5, TILE_SIZE);
                            ctx.fillRect(tx + 25, ty, 5, TILE_SIZE);
                            for(let i=0; i<4; i++) ctx.fillRect(tx+10, ty + (i*10) + 2, 20, 4);
                        }
                        else if(t.type === 5) {
                            ctx.fillStyle = t.active ? "#00ff41" : "#555";
                            ctx.shadowBlur = 20; ctx.shadowColor = ctx.fillStyle;
                            ctx.fillRect(tx+15, ty+10, 5, 30);
                            ctx.beginPath(); ctx.moveTo(tx+20, ty+10); ctx.lineTo(tx+35, ty+15); ctx.lineTo(tx+20, ty+20); ctx.fill();
                            ctx.shadowBlur = 0; ctx.fillStyle = "#333"; ctx.fillRect(tx+5, ty+35, 30, 5);
                        }
                        else if(t.type === 4) {
                            // Spikes / Lava
                            if(t.color === '#e74c3c') { // Lava
                                ctx.fillStyle = t.color;
                                ctx.fillRect(tx, ty + 10, TILE_SIZE, TILE_SIZE - 10);
                                ctx.fillStyle = "orange";
                                ctx.beginPath(); ctx.arc(tx + secureRandom()*40, ty+10, 5, 0, Math.PI*2); ctx.fill();
                            } else {
                                let grd = ctx.createLinearGradient(tx, ty, tx, ty+TILE_SIZE);
                                grd.addColorStop(0, "#ccc"); grd.addColorStop(1, "#555"); ctx.fillStyle = grd;
                                ctx.beginPath(); ctx.moveTo(tx, ty+TILE_SIZE); ctx.lineTo(tx+10, ty); ctx.lineTo(tx+20, ty+TILE_SIZE); ctx.lineTo(tx+30, ty); ctx.lineTo(tx+40, ty+TILE_SIZE); ctx.fill();
                            }
                        }
                        else if (t.type === 1) {
                            // Dirt / Ground
                            let color = C.dirtBase;
                            if (gameState.levelData.biome === 'city') color = "#333";
                            if (gameState.levelData.biome === 'volcano') color = "#422";

                            ctx.fillStyle = color; ctx.fillRect(tx, ty, TILE_SIZE, TILE_SIZE);

                            if (gameState.levelData.biome === 'city') {
                                ctx.fillStyle = "#444"; ctx.fillRect(tx, ty+35, 40, 5); // Piping
                            } else {
                                ctx.fillStyle = C.dirtLight; ctx.fillRect(tx + 5, ty + 5, 10, 10); ctx.fillRect(tx + 25, ty + 20, 8, 8);
                            }

                            if(r > 0 && tiles[r-1][c].type === 0) {
                                if (gameState.levelData.biome === 'city') ctx.fillStyle = "#555"; // Concrete top
                                else if (gameState.levelData.biome === 'volcano') ctx.fillStyle = "#722"; // Charred top
                                else ctx.fillStyle = C.grassTop;
                                ctx.fillRect(tx, ty, TILE_SIZE, 8);
                            }
                        }
                        else if (t.type === 2) {
                            // Stone / Indestructible
                            let color = C.stoneBase;
                            if (gameState.levelData.biome === 'city') color = "#222";
                            ctx.fillStyle = color; ctx.fillRect(tx, ty, TILE_SIZE, TILE_SIZE);
                            ctx.strokeStyle = C.stoneLight; ctx.lineWidth = 2; ctx.beginPath();
                            ctx.moveTo(tx, ty+20); ctx.lineTo(tx+TILE_SIZE, ty+20);
                            ctx.stroke();
                        }
                        else if (t.type === 9) {
                            ctx.fillStyle = "gold"; ctx.shadowBlur=30; ctx.shadowColor="gold";
                            ctx.fillRect(tx, ty, TILE_SIZE, TILE_SIZE); ctx.shadowBlur=0;
                            ctx.fillStyle = "#000"; ctx.font = "10px Arial"; ctx.fillText("VAN", tx+5, ty+25);
                        }
                    }
                }
            }

            debris.forEach(d => d.draw(ctx));
            entities.forEach(e => e.draw(ctx, 0, 0));
            if(player) player.draw(ctx, 0, 0);
            particles.forEach(p => p.draw(ctx));

            ctx.font = "900 20px 'Segoe UI'";
            ctx.lineWidth = 3;
            damageNumbers.forEach(d => {
                ctx.fillStyle = d.color; ctx.strokeStyle = "black";
                ctx.strokeText(d.text, d.x, d.y); ctx.fillText(d.text, d.x, d.y);
            });

            ctx.restore();

            var grd = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 200, canvas.width/2, canvas.height/2, 600);
            grd.addColorStop(0, "transparent"); grd.addColorStop(1, "rgba(0,0,0,0.6)");
            ctx.fillStyle = grd; ctx.fillRect(0,0,canvas.width, canvas.height);
        }

    } catch(e) {
        console.error("Game Loop Draw Error:", e);
        // Visual crash indicator
        ctx.fillStyle = "#ff00ff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        window.onerror(e.message, "loajf.html (Draw Loop)", 0, 0, e);
    }

    requestAnimationFrame(loop);
}

// RESIZE HANDLING
function handleResize() {
    if (canvas) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        // Redraw menu if active, as it's static
        if (gameState.screen === 'MENU') drawMenu();
        if (gameState.screen === 'ROSTER') drawRoster();
    }
}

// MAIN INIT FUNCTION
function init() {
    console.log("INIT() CALLED");
    lastTime = 0;

    // Resize setup
    window.addEventListener('resize', handleResize);
    handleResize();

    // Set to MENU initially
    gameState.screen = 'MENU';
    gameState.running = false;
    gameState.currentLevel = 1;

    // Show Menu UI, Hide Game UI
    document.getElementById('menuOverlay').style.display = 'flex';
    document.getElementById('rosterOverlay').style.display = 'none';
    document.getElementById('gameUI').style.display = 'none';
    document.getElementById('bossHealthContainer').style.display = 'none';
    document.getElementById('gameOverOverlay').style.display = 'none';
    document.getElementById('levelCompleteOverlay').style.display = 'none';
}

// Start actual gameplay
window.startGame = function() {
    console.log("STARTGAME() CALLED");
    try {
        if (typeof rectIntersect !== 'function') throw new Error("CRITICAL: rectIntersect function missing!");

        tiles = generateLevel();
        console.log("LEVEL GENERATED. TILES:", tiles.length);
        particles = [];
        damageNumbers = [];
        debris = [];
        // gameState.spawnPoint = { x: 100, y: 0 }; // Replaced by Heli logic below
        gameState.checkpointsHit = 0;
        // Keep score/rescues if next level, else reset
        if (gameState.screen === 'MENU') {
            gameState.score = 0;
            gameState.rescues = 0;
            gameState.lives = 3;
            gameState.currentLevel = 1;
        }

        gameState.bossActive = false;
        gameState.screen = 'GAME';
        gameState.running = true;

        // Select random unlocked hero
        player = new Player();
        let rnd = Math.floor(secureRandom() * gameState.globalUnlocked);
        player.setCharacter(CHARACTERS[rnd].id);

        // --- HELICOPTER INTRO ---
        // Spawn Heli at start
        let startX = 2 * TILE_SIZE;
        let startY = 2 * TILE_SIZE;
        // Ensure start area is clear of walls (handled by level gen, but let's be safe)

        // Visual Heli (Just a prop or the existing class?)
        // Existing class has update logic that might fly away or extract.
        // We can use the existing Helicopter class but maybe trick it or just spawn it for visuals.
        // Actually, let's just spawn player high up and simulate the drop.
        // Or spawn a "IntroHelicopter" that flies away.

        // Spawn standard Helicopter but at start
        let introHeli = new Helicopter(startX, startY);
        // We need to modify Helicopter to NOT extract player immediately if spawned at start?
        // Helicopter class logic: checkRectOverlap(this, player) -> levelComplete.
        // We should make a separate IntroHelicopter or just place player slightly below it so they fall.

        entities.push(introHeli);

        // Player starts falling from heli
        player.x = startX + 20;
        player.y = startY + 60;
        player.vy = 5; // Initial drop velocity
        gameState.spawnPoint = { x: player.x, y: player.y }; // Update spawn point

        spawnExplosion(player.x, player.y, "#fff", 1); // "Dust off" effect

        // Switch UI
        document.getElementById('menuOverlay').style.display = 'none';
        document.getElementById('gameUI').style.display = 'flex';
        document.getElementById('levelCompleteOverlay').style.display = 'none';
        updateUI();

        // Reset Time so we don't jump
        lastTime = 0;
    } catch (e) {
        console.error("Error starting game:", e);
        // Force error overlay
        window.onerror(e.message, "loajf.html (startGame)", 0, 0, e);
        // Fallback
        gameState.screen = 'MENU';
        document.getElementById('menuOverlay').style.display = 'flex';
        document.getElementById('gameUI').style.display = 'none';
    }
}

// Next Level Logic
window.nextLevel = function() {
    gameState.currentLevel++;
    gameState.score += 1000;
    window.startGame();
};

// Return to menu
window.returnToBase = function() {
    init();
}

// Restart level (keep unlocks)
window.resetGame = function() {
    window.startGame();
};

window.viewRoster = function() {
    gameState.screen = 'ROSTER';
    document.getElementById('menuOverlay').style.display = 'none';
    document.getElementById('rosterOverlay').style.display = 'flex';
};

window.returnToMenu = function() {
    gameState.screen = 'MENU';
    document.getElementById('rosterOverlay').style.display = 'none';
    document.getElementById('menuOverlay').style.display = 'flex';
};

// Start App
init();
requestAnimationFrame(loop);



})();
</script>


</body>
</html>
